<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ðŸŒŠ Infinite Spectrogram - GPU Viewport</title>
    <style>
        /* Same styles as before */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #ddd;
            padding: 20px;
        }
        .container { max-width: 1400px; margin: 0 auto; }
        h1 { color: #4a9eff; margin-bottom: 10px; }
        .subtitle { color: #888; margin-bottom: 20px; font-size: 14px; }
        
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
        .control-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-size: 12px; color: #aaa; text-transform: uppercase; }
        
        input[type="range"] {
            width: 400px;
            height: 6px;
            background: #444;
            border-radius: 3px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .value-display {
            font-size: 20px;
            font-weight: bold;
            color: #4a9eff;
        }
        
        .info-panel {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .info-item { display: flex; flex-direction: column; gap: 4px; }
        .info-label { color: #888; font-size: 11px; text-transform: uppercase; }
        .info-value { color: #4a9eff; font-weight: bold; font-size: 16px; }
        
        .canvas-container {
            position: relative;
            background: #000;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            width: 100%;
            image-rendering: auto;
        }
        
        .render-status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŠ Infinite Spectrogram Space - GPU Viewport</h1>
        <p class="subtitle">ONE render at neutral (1x), GPU-stretch on demand, infinite canvas (near-zero CPU hit!)</p>
        
        <div class="controls">
            <div class="control-group">
                <label>Playback Speed</label>
                <input type="range" id="speedSlider" min="0" max="1000" step="1" value="500">
                <div class="value-display" id="speedValue">1.0x</div>
            </div>
            <div class="control-group">
                <label>Mode</label>
                <select id="modeSelect" style="padding: 8px; background: #333; color: #ddd; border: 1px solid #555; border-radius: 4px;">
                    <option value="gpu">GPU-Accelerated (Viewport Extract)</option>
                    <option value="cpu">CPU Re-Render (Full Render Each Time)</option>
                </select>
            </div>
        </div>
        
        <div class="info-panel">
            <div class="info-item">
                <span class="info-label">Infinite Canvas (Neutral 1x Render)</span>
                <span class="info-value" id="canvasSize">1200 Ã— 6750 px</span>
            </div>
            <div class="info-item">
                <span class="info-label">Display Viewport</span>
                <span class="info-value">1200 Ã— 450 px</span>
            </div>
            <div class="info-item">
                <span class="info-label">Effective Nyquist</span>
                <span class="info-value" id="nyquist">50.0 Hz</span>
            </div>
            <div class="info-item">
                <span class="info-label">Visible Range</span>
                <span class="info-value" id="visibleRange">0 - 50.0 Hz</span>
            </div>
            <div class="info-item">
                <span class="info-label">Source Rect Height</span>
                <span class="info-value" id="sourceHeight">450 px</span>
            </div>
            <div class="info-item">
                <span class="info-label">FPS (Viewport Update)</span>
                <span class="info-value" id="fps">60 fps</span>
            </div>
            <div class="info-item">
                <span class="info-label">CPU: Full Render (One-Time)</span>
                <span class="info-value" id="renderTime">-- ms</span>
            </div>
            <div class="info-item">
                <span class="info-label">CPU: Viewport Extract (GPU)</span>
                <span class="info-value" id="viewportTime">~0 ms</span>
            </div>
            <div class="info-item">
                <span class="info-label">CPU: Avg Per Frame (GPU)</span>
                <span class="info-value" id="avgFrameTime">~0 ms</span>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="displayCanvas" width="1200" height="450"></canvas>
            <div class="render-status" id="renderStatus">ðŸŽ¨ Rendering at max scale...</div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const SAMPLE_RATE = 100;
        const VIEWPORT_HEIGHT = 450;
        const VIEWPORT_WIDTH = 1200;
        const MAX_PLAYBACK_RATE = 15.0;
        const ORIGINAL_NYQUIST = SAMPLE_RATE / 2;
        
        // ===== INFINITE CANVAS (6750px) =====
        const infiniteCanvas = document.createElement('canvas');
        infiniteCanvas.width = VIEWPORT_WIDTH;
        infiniteCanvas.height = VIEWPORT_HEIGHT * MAX_PLAYBACK_RATE; // 6,750 px
        const infiniteCtx = infiniteCanvas.getContext('2d');
        
        // Temp canvas for neutral (1x) render
        let neutralRenderCanvas = null;
        
        console.log(`ðŸŽ¨ Infinite canvas: ${infiniteCanvas.width} Ã— ${infiniteCanvas.height} px`);
        
        // ===== GENERATE SPECTROGRAM DATA =====
        function generateSpectrogramData() {
            const fftSize = 512;
            const frequencyBinCount = fftSize / 2;
            const hopSize = fftSize / 4;
            const numTimeSlices = Math.floor((SAMPLE_RATE * 60 - fftSize) / hopSize);
            
            const data = [];
            
            for (let t = 0; t < numTimeSlices; t++) {
                const magnitudes = new Float32Array(frequencyBinCount);
                
                for (let bin = 0; bin < frequencyBinCount; bin++) {
                    const freq = (bin / frequencyBinCount) * ORIGINAL_NYQUIST; // Neutral 1x scale
                    
                    let magnitude = 0;
                    
                    // Frequency bands (at neutral 1x scale, 0-50Hz)
                    if (freq >= 2 && freq <= 5) magnitude += 0.8;
                    if (freq >= 10 && freq <= 15) magnitude += 0.9;
                    if (freq >= 25 && freq <= 30) magnitude += 0.7;
                    if (freq >= 45 && freq <= 50) magnitude += 0.6;
                    
                    magnitude += Math.random() * 0.15;
                    magnitudes[bin] = Math.max(0, Math.min(1, magnitude));
                }
                
                data.push(magnitudes);
            }
            
            return { data, frequencyBinCount, numTimeSlices };
        }
        
        // ===== HSL TO RGB =====
        function hslToRgb(h, s, l) {
            h /= 360; s /= 100; l /= 100;
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        // ===== GET Y POSITION (NEUTRAL - NO PLAYBACK RATE!) =====
        function getYPosition(binIndex, totalBins, canvasHeight) {
            // ðŸ”¥ NO playback rate - render at neutral 1x always
            const normalized = binIndex / totalBins;
            const sqrtNormalized = Math.sqrt(normalized);
            return canvasHeight - (sqrtNormalized * canvasHeight);
        }
        
        // ===== RENDER FULL SPECTROGRAM (ONCE AT NEUTRAL 1X!) =====
        function renderFullSpectrogram() {
            console.log('ðŸŽ¨ Rendering spectrogram at NEUTRAL (1x) scale...');
            const startTime = performance.now();
            
            const { data, frequencyBinCount, numTimeSlices } = generateSpectrogramData();
            
            // Create temp canvas for neutral render (450px)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = VIEWPORT_WIDTH;
            tempCanvas.height = VIEWPORT_HEIGHT; // Always 450px
            const tempCtx = tempCanvas.getContext('2d');
            
            const pixelsPerSlice = tempCanvas.width / numTimeSlices;
            
            // Color lookup table
            const colorLUT = [];
            for (let i = 0; i < 256; i++) {
                const normalized = i / 255;
                const hue = normalized * 60;
                const rgb = hslToRgb(hue, 100, 10 + normalized * 60);
                colorLUT.push(rgb);
            }
            
            // Clear temp canvas
            tempCtx.fillStyle = '#000';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Render at NEUTRAL (1x) scale - NO playback rate scaling!
            for (let t = 0; t < numTimeSlices; t++) {
                const xStart = Math.floor(t * pixelsPerSlice);
                const xEnd = Math.floor((t + 1) * pixelsPerSlice);
                const magnitudes = data[t];
                
                for (let bin = 0; bin < frequencyBinCount; bin++) {
                    const magnitude = magnitudes[bin];
                    const db = 20 * Math.log10(magnitude + 1e-10);
                    const normalizedDb = Math.max(0, Math.min(1, (db + 100) / 100));
                    const colorIndex = Math.floor(normalizedDb * 255);
                    const [r, g, b] = colorLUT[colorIndex];
                    
                    // Square root scale (NEUTRAL - no playback rate!)
                    const yStart = Math.floor(getYPosition(bin, frequencyBinCount, tempCanvas.height));
                    const yEnd = Math.floor(getYPosition(bin + 1, frequencyBinCount, tempCanvas.height));
                    
                    tempCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                    for (let x = xStart; x < xEnd; x++) {
                        for (let y = yEnd; y < yStart; y++) {
                            tempCtx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
            
            // Store neutral render
            neutralRenderCanvas = tempCanvas;
            
            // Create infinite canvas (6750px) and fill with black
            infiniteCtx.fillStyle = '#000';
            infiniteCtx.fillRect(0, 0, infiniteCanvas.width, infiniteCanvas.height);
            
            // Place 450px render at BOTTOM of infinite canvas (no stretching yet)
            infiniteCtx.drawImage(tempCanvas, 0, infiniteCanvas.height - VIEWPORT_HEIGHT);
            
            const elapsed = performance.now() - startTime;
            console.log(`âœ… Neutral spectrogram rendered in ${elapsed.toFixed(0)}ms`);
            console.log(`   Placed 450px render at bottom of ${infiniteCanvas.height}px infinite canvas`);
            
            // Update CPU metrics
            document.getElementById('renderTime').textContent = `${elapsed.toFixed(0)} ms`;
            
            document.getElementById('renderStatus').textContent = `âœ… Rendered in ${elapsed.toFixed(0)}ms (NEUTRAL 1x)`;
            setTimeout(() => {
                document.getElementById('renderStatus').style.display = 'none';
            }, 3000);
        }
        
        // ===== UPDATE VIEWPORT (GPU-ACCELERATED!) =====
        let frameCount = 0;
        let lastFpsUpdate = performance.now();
        let viewportUpdateTimes = [];
        const MAX_SAMPLES = 60; // Keep last 60 frames for average
        
        function updateViewport(playbackRate) {
            const startTime = performance.now();
            
            const displayCanvas = document.getElementById('displayCanvas');
            const ctx = displayCanvas.getContext('2d');
            
            // Step 1: GPU-stretch the 450px neutral render vertically
            const stretchedHeight = VIEWPORT_HEIGHT * playbackRate;
            
            // Create temp canvas for stretching
            const tempStretch = document.createElement('canvas');
            tempStretch.width = VIEWPORT_WIDTH;
            tempStretch.height = stretchedHeight;
            const stretchCtx = tempStretch.getContext('2d');
            
            // GPU-stretch: Extract 450px from bottom of infinite canvas, stretch vertically
            stretchCtx.drawImage(
                infiniteCanvas,
                0, infiniteCanvas.height - VIEWPORT_HEIGHT,  // Source: bottom 450px
                VIEWPORT_WIDTH, VIEWPORT_HEIGHT,             // Source size
                0, 0,                                       // Dest: top-left
                VIEWPORT_WIDTH, stretchedHeight             // Dest: stretched!
            );
            
            // Step 2: Extract bottom 450px of stretched image to viewport
            ctx.clearRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
            ctx.drawImage(
                tempStretch,
                0, stretchedHeight - VIEWPORT_HEIGHT,  // Source: bottom of stretched
                VIEWPORT_WIDTH, VIEWPORT_HEIGHT,      // Source size
                0, 0,                                 // Dest: top-left
                VIEWPORT_WIDTH, VIEWPORT_HEIGHT       // Dest size
            );
            
            // Measure CPU time for this viewport update
            const viewportUpdateTime = performance.now() - startTime;
            viewportUpdateTimes.push(viewportUpdateTime);
            if (viewportUpdateTimes.length > MAX_SAMPLES) {
                viewportUpdateTimes.shift();
            }
            
            // Calculate average frame time
            const avgFrameTime = viewportUpdateTimes.reduce((a, b) => a + b, 0) / viewportUpdateTimes.length;
            
            // Update CPU metrics (GPU work shows as ~0ms - that's the feature!)
            // The actual image extraction/scaling happens on GPU, not CPU
            document.getElementById('viewportTime').textContent = `${viewportUpdateTime.toFixed(3)} ms (GPU)`;
            document.getElementById('avgFrameTime').textContent = `${avgFrameTime.toFixed(3)} ms (GPU)`;
            
            // Update FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastFpsUpdate >= 1000) {
                document.getElementById('fps').textContent = `${frameCount} fps`;
                frameCount = 0;
                lastFpsUpdate = now;
            }
            
            // Update info panel
            const effectiveNyquist = ORIGINAL_NYQUIST * playbackRate;
            // At 1x: stretched to 450px â†’ extract bottom 450px â†’ see everything (0-50Hz)
            // At 15x: stretched to 6750px â†’ extract bottom 450px â†’ see bottom 1/15th (0-3.3Hz)
            const viewportFreqMax = ORIGINAL_NYQUIST / playbackRate;
            
            document.getElementById('nyquist').textContent = `${effectiveNyquist.toFixed(1)} Hz`;
            document.getElementById('visibleRange').textContent = `0 - ${viewportFreqMax.toFixed(1)} Hz`;
            document.getElementById('sourceHeight').textContent = `${stretchedHeight.toFixed(0)} px (stretched)`;
        }
        
        // ===== LOGARITHMIC SLIDER MAPPING (matching production) =====
        function sliderValueToPlaybackRate(sliderValue) {
            const value = parseFloat(sliderValue);
            
            // Logarithmic mapping: 0-1000 -> 0.5-15, with 500 = 1.0
            let playbackRate;
            if (value <= 500) {
                // 0-500 maps to 0.5-1.0 (logarithmic)
                const normalized = value / 500;
                playbackRate = 0.5 * Math.pow(2, normalized); // 0.5 * 2^normalized
            } else {
                // 500-1000 maps to 1.0-15 (exponential)
                const normalized = (value - 500) / 500;
                playbackRate = Math.pow(15, normalized);
            }
            
            // Round to nearest 0.01 for display
            return Math.round(playbackRate * 100) / 100;
        }
        
        function playbackRateToSliderValue(playbackRate) {
            if (playbackRate <= 1.0) {
                // 0.5-1.0 maps to 0-500
                const normalized = Math.log2(playbackRate / 0.5);
                return Math.round(normalized * 500);
            } else {
                // 1.0-15 maps to 500-1000
                const normalized = Math.log(playbackRate) / Math.log(15);
                return Math.round(500 + normalized * 500);
            }
        }
        
        // ===== EVENT HANDLERS =====
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const sliderValue = parseFloat(e.target.value);
            const rate = sliderValueToPlaybackRate(sliderValue);
            document.getElementById('speedValue').textContent = `${rate.toFixed(2)}x`;
            updateViewport(rate);
        });
        
        // ===== INITIALIZE =====
        console.log('ðŸŒŠ Initializing...');
        renderFullSpectrogram();  // ONE TIME render
        
        // Set initial slider position for 1.0x
        document.getElementById('speedSlider').value = playbackRateToSliderValue(1.0);
        updateViewport(1.0);       // Initial viewport
        console.log('âœ… Ready! Move the slider - GPU does the rest.');
    </script>
</body>
</html>
