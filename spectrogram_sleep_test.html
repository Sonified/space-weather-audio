<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram-Style Sleep Test - Event Handler Permutations</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
            margin: 0;
        }

        h1 {
            text-align: center;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }

        .instructions {
            background: #111;
            border: 2px solid #0f0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .instructions h3 {
            margin-top: 0;
            color: #ff6600;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }

        .canvas-wrapper {
            border: 3px solid #333;
            border-radius: 5px;
            padding: 10px;
            background: #0a0a0a;
            transition: border-color 0.3s;
            position: relative;
        }

        .canvas-wrapper:hover {
            border-color: #ff6600;
        }

        .canvas-wrapper.active {
            border-color: #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .method-label {
            text-align: center;
            font-weight: bold;
            color: #ff6600;
            margin-bottom: 10px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .canvas-container {
            position: relative;
            display: inline-block;
        }

        canvas.main-canvas {
            display: block;
            width: 300px;
            height: 200px;
            border: 1px solid #444;
            background: #1a1a1a;
            cursor: crosshair;
            border-radius: 3px;
        }

        canvas.overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .status {
            text-align: center;
            margin-top: 5px;
            font-size: 11px;
            color: #0f0;
            min-height: 40px;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        button {
            background: #ff6600;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }

        button:hover {
            background: #ff9933;
            box-shadow: 0 0 10px #ff6600;
        }

        .results {
            background: #111;
            border: 2px solid #0f0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .winner {
            color: #ff6600;
            font-weight: bold;
            font-size: 18px;
        }

        .flags {
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>üî• SPECTROGRAM-STYLE SLEEP TEST üî•</h1>

    <div class="instructions">
        <h3>üíÄ TEST PROTOCOL üíÄ</h3>
        <ol>
            <li><strong>DRAW BOXES:</strong> Click and drag red selection boxes on each canvas</li>
            <li><strong>SLEEP:</strong> Put your computer to sleep</li>
            <li><strong>WAKE:</strong> Wake up and try clicking/dragging on each canvas</li>
            <li><strong>VERDICT:</strong> Check which ones still track mouse properly</li>
        </ol>
        <p><strong>‚ö†Ô∏è CRITICAL:</strong> All canvases use spectrogram-style overlay rendering. They differ only in event handlers!</p>
    </div>

    <div class="controls">
        <button onclick="clearAll()">CLEAR ALL</button>
        <button onclick="showResults()">SHOW RESULTS</button>
    </div>

    <div class="grid-container" id="grid">
        <!-- Canvases will be generated here -->
    </div>

    <div class="results" id="results" style="display: none;">
        <h3>üèÜ TEST RESULTS üèÜ</h3>
        <div id="resultsContent"></div>
    </div>

    <script>
        // Helper function to get canvas coordinates (CSS pixels)
        function getCanvasCoords(e, canvas) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Test configurations - each tests different event handler combinations
        const testConfigs = [
            {
                name: "1: Waveform Style",
                description: "mouseleave + mouseenter ONLY (no sleep handlers)",
                flags: "mouseleave, mouseenter",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {
                    if (this.selectionActive) {
                        this.selectionActive = false;
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                        this.redraw();
                    }
                },
                mouseenter: function() {
                    // Just reset cursor or state if needed
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    
                    // Draw completed boxes
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    
                    // Draw current dragging box
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "2: Current Spectrogram",
                description: "visibilitychange + focus + blur + mouseleave + mouseenter",
                flags: "visibilitychange, focus, blur, mouseleave, mouseenter",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    // Add visibilitychange handler
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible') {
                            if (this.selectionActive) {
                                console.log(`[${this.name}] üëÅÔ∏è Visibility: canceling active selection`);
                                this.cancelSelection();
                            }
                            if (!this.selectionActive && (this.startX !== null || this.currentX !== null)) {
                                console.log(`[${this.name}] üëÅÔ∏è Visibility: resetting stale coords`);
                                this.startX = null;
                                this.startY = null;
                                this.currentX = null;
                                this.currentY = null;
                            }
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                    
                    // Add focus handler
                    this.focusHandler = () => {
                        if (this.selectionActive) {
                            console.log(`[${this.name}] üéØ Focus: canceling active selection`);
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('focus', this.focusHandler);
                    
                    // Add blur handler
                    this.blurHandler = () => {
                        if (this.selectionActive) {
                            console.log(`[${this.name}] üëã Blur: canceling active selection`);
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('blur', this.blurHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {
                    if (this.selectionActive) {
                        console.log(`[${this.name}] üñ±Ô∏è Mouseleave: canceling`);
                        this.cancelSelection();
                    }
                },
                mouseenter: function() {
                    if (!this.selectionActive && (this.startX !== null || this.currentX !== null)) {
                        console.log(`[${this.name}] üñ±Ô∏è Mouseenter: resetting stale coords`);
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                    }
                },
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "3: Visibility Only",
                description: "visibilitychange ONLY (no focus/blur)",
                flags: "visibilitychange",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible') {
                            if (this.selectionActive) {
                                this.cancelSelection();
                            }
                            if (!this.selectionActive && (this.startX !== null || this.currentX !== null)) {
                                this.startX = null;
                                this.startY = null;
                                this.currentX = null;
                                this.currentY = null;
                            }
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {},
                mouseenter: function() {},
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "4: Focus/Blur Only",
                description: "focus + blur ONLY (no visibilitychange)",
                flags: "focus, blur",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.focusHandler = () => {
                        if (this.selectionActive) {
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('focus', this.focusHandler);
                    
                    this.blurHandler = () => {
                        if (this.selectionActive) {
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('blur', this.blurHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {},
                mouseenter: function() {},
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "5: Mouseenter Reset",
                description: "visibilitychange + mouseenter reset (no focus/blur)",
                flags: "visibilitychange, mouseenter",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible') {
                            if (this.selectionActive) {
                                this.cancelSelection();
                            }
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {},
                mouseenter: function() {
                    if (!this.selectionActive && (this.startX !== null || this.currentX !== null)) {
                        console.log(`[${this.name}] üñ±Ô∏è Mouseenter: resetting stale coords`);
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                    }
                },
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "6: No Sleep Handlers",
                description: "mouseleave + mouseenter ONLY (like waveform)",
                flags: "mouseleave, mouseenter",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {
                    if (this.selectionActive) {
                        this.selectionActive = false;
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                        this.redraw();
                    }
                },
                mouseenter: function() {
                    // Reset stale state if any
                    if (!this.selectionActive && (this.startX !== null || this.currentX !== null)) {
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                    }
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "7: Aggressive Reset",
                description: "ALL handlers + aggressive mouseenter reset",
                flags: "visibilitychange, focus, blur, mouseleave, mouseenter",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible') {
                            console.log(`[${this.name}] üëÅÔ∏è Visibility: aggressive reset`);
                            this.startX = null;
                            this.startY = null;
                            this.currentX = null;
                            this.currentY = null;
                            if (this.selectionActive) {
                                this.cancelSelection();
                            }
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                    
                    this.focusHandler = () => {
                        console.log(`[${this.name}] üéØ Focus: aggressive reset`);
                        this.startX = null;
                        this.startY = null;
                        this.currentX = null;
                        this.currentY = null;
                        if (this.selectionActive) {
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('focus', this.focusHandler);
                    
                    this.blurHandler = () => {
                        if (this.selectionActive) {
                            this.cancelSelection();
                        }
                    };
                    window.addEventListener('blur', this.blurHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {
                    if (this.selectionActive) {
                        this.cancelSelection();
                    }
                },
                mouseenter: function() {
                    // Aggressive reset on mouseenter
                    console.log(`[${this.name}] üñ±Ô∏è Mouseenter: aggressive reset`);
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    if (this.selectionActive) {
                        this.cancelSelection();
                    }
                },
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "8: Minimal Reset",
                description: "visibilitychange ONLY, minimal reset",
                flags: "visibilitychange",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible' && this.selectionActive) {
                            this.cancelSelection();
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {},
                mouseenter: function() {},
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            },
            {
                name: "9: Force Reinit",
                description: "visibilitychange + force canvas reinit on wake",
                flags: "visibilitychange, force-reinit",
                init: function(ctx, overlayCtx, canvas, overlayCanvas) {
                    this.ctx = ctx;
                    this.overlayCtx = overlayCtx;
                    this.canvas = canvas;
                    this.overlayCanvas = overlayCanvas;
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.completedBoxes = [];
                    
                    this.visibilityHandler = () => {
                        if (document.visibilityState === 'visible') {
                            console.log(`[${this.name}] üëÅÔ∏è Visibility: forcing canvas reinit`);
                            // Force canvas context refresh
                            this.redraw();
                            // Reset all state
                            this.startX = null;
                            this.startY = null;
                            this.currentX = null;
                            this.currentY = null;
                            if (this.selectionActive) {
                                this.cancelSelection();
                            }
                        }
                    };
                    document.addEventListener('visibilitychange', this.visibilityHandler);
                },
                mousedown: function(e) {
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.startX = x;
                    this.startY = y;
                    this.currentX = null;
                    this.currentY = null;
                    this.selectionActive = true;
                },
                mousemove: function(e) {
                    if (!this.selectionActive) return;
                    const {x, y} = getCanvasCoords(e, this.canvas);
                    this.currentX = x;
                    this.currentY = y;
                    this.redraw();
                },
                mouseup: function(e) {
                    if (!this.selectionActive) return;
                    if (this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            this.completedBoxes.push({
                                startX: this.startX,
                                startY: this.startY,
                                endX: this.currentX,
                                endY: this.currentY
                            });
                        }
                    }
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                mouseleave: function() {},
                mouseenter: function() {},
                cancelSelection: function() {
                    this.selectionActive = false;
                    this.startX = null;
                    this.startY = null;
                    this.currentX = null;
                    this.currentY = null;
                    this.redraw();
                },
                redraw: function() {
                    this.overlayCtx.clearRect(0, 0, this.overlayCanvas.width, this.overlayCanvas.height);
                    this.overlayCtx.strokeStyle = '#ff4444';
                    this.overlayCtx.lineWidth = 2;
                    this.overlayCtx.fillStyle = 'rgba(255, 68, 68, 0.2)';
                    this.completedBoxes.forEach(box => {
                        const x = Math.min(box.startX, box.endX);
                        const y = Math.min(box.startY, box.endY);
                        const w = Math.abs(box.endX - box.startX);
                        const h = Math.abs(box.endY - box.startY);
                        this.overlayCtx.fillRect(x, y, w, h);
                        this.overlayCtx.strokeRect(x, y, w, h);
                    });
                    if (this.selectionActive && this.currentX !== null && this.currentY !== null) {
                        const dragDist = Math.max(
                            Math.abs(this.currentX - this.startX),
                            Math.abs(this.currentY - this.startY)
                        );
                        if (dragDist >= 5) {
                            const x = Math.min(this.startX, this.currentX);
                            const y = Math.min(this.startY, this.currentY);
                            const w = Math.abs(this.currentX - this.startX);
                            const h = Math.abs(this.currentY - this.startY);
                            this.overlayCtx.fillRect(x, y, w, h);
                            this.overlayCtx.strokeRect(x, y, w, h);
                        }
                    }
                }
            }
        ];

        const instances = [];

        // Initialize grid
        function initGrid() {
            const grid = document.getElementById('grid');

            testConfigs.forEach((config, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';
                wrapper.id = `wrapper-${index}`;

                const label = document.createElement('div');
                label.className = 'method-label';
                label.textContent = config.name;

                const container = document.createElement('div');
                container.className = 'canvas-container';

                const mainCanvas = document.createElement('canvas');
                mainCanvas.className = 'main-canvas';
                mainCanvas.width = 300;
                mainCanvas.height = 200;
                mainCanvas.id = `canvas-${index}`;

                const overlayCanvas = document.createElement('canvas');
                overlayCanvas.className = 'overlay-canvas';
                overlayCanvas.width = 300;
                overlayCanvas.height = 200;
                overlayCanvas.id = `overlay-${index}`;
                overlayCanvas.style.width = '300px';
                overlayCanvas.style.height = '200px';

                container.appendChild(mainCanvas);
                container.appendChild(overlayCanvas);

                const status = document.createElement('div');
                status.className = 'status';
                status.id = `status-${index}`;
                status.innerHTML = `<div>${config.description}</div><div class="flags">Flags: ${config.flags}</div>`;

                wrapper.appendChild(label);
                wrapper.appendChild(container);
                wrapper.appendChild(status);
                grid.appendChild(wrapper);

                // Initialize method
                const ctx = mainCanvas.getContext('2d');
                const overlayCtx = overlayCanvas.getContext('2d');
                
                // Draw background on main canvas
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
                
                const instance = Object.create(config);
                instance.name = config.name;
                instance.init(ctx, overlayCtx, mainCanvas, overlayCanvas);
                instances.push(instance);

                // Add event listeners
                mainCanvas.addEventListener('mousedown', (e) => {
                    wrapper.classList.add('active');
                    updateStatus(index, 'Drawing...');
                    instance.mousedown(e);
                });

                mainCanvas.addEventListener('mousemove', (e) => {
                    instance.mousemove(e);
                });

                mainCanvas.addEventListener('mouseup', (e) => {
                    wrapper.classList.remove('active');
                    updateStatus(index, 'Ready');
                    instance.mouseup(e);
                });

                mainCanvas.addEventListener('mouseleave', (e) => {
                    wrapper.classList.remove('active');
                    instance.mouseleave(e);
                    updateStatus(index, 'Ready');
                });

                mainCanvas.addEventListener('mouseenter', (e) => {
                    instance.mouseenter(e);
                });
            });
        }

        function updateStatus(index, text) {
            const statusEl = document.getElementById(`status-${index}`);
            const parts = statusEl.innerHTML.split('<div class="flags">');
            statusEl.innerHTML = `<div>${text}</div><div class="flags">${parts[1]}`;
        }

        function clearAll() {
            instances.forEach((instance, index) => {
                const overlayCanvas = document.getElementById(`overlay-${index}`);
                const overlayCtx = overlayCanvas.getContext('2d');
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                // Reset instance data
                instance.completedBoxes = [];
                instance.selectionActive = false;
                instance.startX = null;
                instance.startY = null;
                instance.currentX = null;
                instance.currentY = null;

                updateStatus(index, 'Cleared');
            });
        }

        function showResults() {
            const results = document.getElementById('results');
            const content = document.getElementById('resultsContent');

            let html = '<p>Mouse tracking test results (check console for event logs):</p><ul>';

            instances.forEach((instance, index) => {
                const overlayCanvas = document.getElementById(`overlay-${index}`);
                const overlayCtx = overlayCanvas.getContext('2d');
                const imageData = overlayCtx.getImageData(0, 0, overlayCanvas.width, overlayCanvas.height);

                // Check if canvas has any red pixels
                let hasRed = false;
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    // Check for red-ish pixels (selection boxes)
                    if (r > 200 && g < 100 && b < 100) {
                        hasRed = true;
                        break;
                    }
                }

                const state = instance.selectionActive ? 'ACTIVE' : 'IDLE';
                const boxes = instance.completedBoxes.length;
                html += `<li><strong>${testConfigs[index].name}:</strong> State: ${state}, Boxes: ${boxes}, Has Red: ${hasRed ? 'YES' : 'NO'}</li>`;
            });

            html += '</ul>';
            html += '<p><strong>After sleep test:</strong> Try clicking/dragging on each canvas and check which ones respond properly.</p>';
            content.innerHTML = html;
            results.style.display = 'block';
        }

        // Initialize on load
        window.addEventListener('load', initGrid);
    </script>
</body>
</html>


