<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéß</text></svg>">
    <title>Stretch Algorithm Comparison</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        h1 {
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .panel {
            background: #252540;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .panel h2 {
            margin-top: 0;
            color: #00d4ff;
            font-size: 1.1em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .file-drop {
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-drop:hover, .file-drop.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.05);
        }

        .file-drop input {
            display: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #00b8e6;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #444;
            color: #888;
            cursor: not-allowed;
            transform: none;
        }

        @keyframes pulse-glow {
            0%, 100% {
                box-shadow: 0 0 5px #00d4ff, 0 0 10px #00d4ff;
                background: #00d4ff;
            }
            50% {
                box-shadow: 0 0 20px #00d4ff, 0 0 35px #00d4ff;
                background: #40e0ff;
            }
        }

        button.pulse {
            animation: pulse-glow 1.5s ease-in-out infinite;
        }

        #playBtn {
            width: 110px;
        }

        .loop-btn {
            background: #333;
            color: #888;
        }

        .loop-btn:hover {
            background: #444;
            color: #aaa;
        }

        .loop-btn.active {
            background: #00d4ff;
            color: #1a1a2e;
        }

        .slider-group {
            flex: 1;
            min-width: 200px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 8px;
            color: #aaa;
        }

        .slider-group label span {
            color: #00d4ff;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00d4ff;
            cursor: pointer;
        }

        select {
            background: #333;
            color: #eee;
            border: 1px solid #444;
            padding: 10px 15px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        .status {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            color: #888;
            min-height: 60px;
        }

        .status.active {
            color: #00ff88;
        }

        .status.error {
            color: #ff4444;
        }

        .track-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .track-item {
            background: #333355;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            border: 1px solid #444;
            margin-right: 10px;
            margin-bottom: 5px;
        }

        .track-item:hover {
            background: #00d4ff;
            color: #1a1a2e;
            border-color: #00d4ff;
        }

        .track-item.active {
            background: #00d4ff;
            color: #1a1a2e;
            border-color: #00d4ff;
        }

        .track-name {
            font-weight: 500;
        }

        .track-size {
            color: #666;
            font-size: 0.9em;
        }

        .waveform-container {
            height: 100px;
            background: #1a1a2e;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .playhead {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #ff4444;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Stretch Algorithm Comparison</h1>

        <!-- 1. Load Audio -->
        <div class="panel">
            <h2>1. Load Audio</h2>
            <div class="track-list" id="trackList">
                <!-- Test tracks will be listed here -->
            </div>
            <div class="file-drop" id="fileDrop" style="margin-top: 15px; padding: 15px;">
                <p style="margin: 0; font-size: 14px;">Or drop/browse for a file</p>
                <input type="file" id="fileInput" accept=".wav,audio/*">
            </div>
        </div>

        <!-- 2. Stretch -->
        <div class="panel">
            <h2>2. Stretch Settings</h2>
            <div class="controls" style="margin-bottom: 15px;">
                <div class="slider-group">
                    <label>Algorithm</label>
                    <select id="algorithmSelect">
                        <option value="resample">Resample (pitch shift)</option>
                        <option value="spectral" selected>FFT (Spectral)</option>
                        <option value="granular">Granular</option>
                    </select>
                </div>

                <div class="slider-group">
                    <label><span id="windowLabel">Window Size</span>: <span id="windowValue">4096</span></label>
                    <select id="windowSelect">
                        <option value="1024">1024 (crisp)</option>
                        <option value="2048">2048</option>
                        <option value="4096" selected>4096 (balanced)</option>
                        <option value="8192">8192</option>
                        <option value="16384">16384 (smooth)</option>
                    </select>
                </div>
            </div>
            <div class="controls">
                <div class="slider-group" style="flex: 1;">
                    <label>Stretch: <span id="stretchValue">2.0</span>x</label>
                    <input type="range" id="stretchSlider" min="0" max="100" step="1" value="30">
                </div>

                <div class="slider-group" style="flex: 1;">
                    <label>Overlap: <span id="overlapValue">90</span>%</label>
                    <input type="range" id="overlapSlider" min="50" max="95" step="2.5" value="90">
                </div>
            </div>
        </div>

        <!-- 3. Playback -->
        <div class="panel">
            <h2>3. Playback</h2>
            <div class="controls" style="margin-bottom: 15px;">
                <button id="playBtn" disabled>‚ñ∂ Play</button>
                <button id="stopBtn" disabled>‚ñ† Stop</button>
                <button id="loopBtn" class="loop-btn">‚ü≥ Loop</button>
                <div class="status" id="status" style="flex: 1; margin: 0; min-height: auto; padding: 10px;">Ready. Load an audio file to begin.</div>
            </div>
            <div class="waveform-container">
                <canvas id="waveformCanvas"></canvas>
                <div class="playhead" id="playhead" style="left: 0"></div>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBAL STATE =====
        let audioContext = null;
        let stretchNode = null;
        let sourceBuffer = null;
        let isPlaying = false;
        let isLooping = false;
        let currentAlgorithm = 'spectral';

        // Playhead tracking
        let playStartTime = 0;
        let playStartPosition = 0; // Position in source (seconds)
        let animationFrameId = null;

        // For resuming after algorithm switch
        let pendingResume = null; // { position, shouldPlay }

        // ===== DOM ELEMENTS =====
        const fileDrop = document.getElementById('fileDrop');
        const fileInput = document.getElementById('fileInput');
        const trackList = document.getElementById('trackList');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loopBtn = document.getElementById('loopBtn');
        const stretchSlider = document.getElementById('stretchSlider');
        const stretchValue = document.getElementById('stretchValue');
        const windowSelect = document.getElementById('windowSelect');
        const windowValue = document.getElementById('windowValue');
        const windowLabel = document.getElementById('windowLabel');
        const overlapSlider = document.getElementById('overlapSlider');
        const overlapValue = document.getElementById('overlapValue');
        const algorithmSelect = document.getElementById('algorithmSelect');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const playhead = document.getElementById('playhead');
        const status = document.getElementById('status');

        // ===== UTILITY FUNCTIONS =====

        // Exponential mapping for stretch slider: more resolution at low values
        // slider 0-100 ‚Üí stretch 1-10 exponentially
        function sliderToStretch(sliderValue) {
            return Math.pow(10, sliderValue / 100);
        }

        // ===== INITIALIZATION =====

        async function initAudio() {
            if (audioContext) return;

            audioContext = new AudioContext({ sampleRate: 44100 });

            // Load all worklet modules
            await audioContext.audioWorklet.addModule('workers/resample-stretch-processor.js');
            await audioContext.audioWorklet.addModule('workers/spectral-stretch-processor.js');
            await audioContext.audioWorklet.addModule('workers/granular-stretch-processor.js');

            createStretchNode();
        }

        function createStretchNode() {
            // Disconnect old node if exists
            if (stretchNode) {
                stretchNode.disconnect();
            }

            currentAlgorithm = algorithmSelect.value;

            if (currentAlgorithm === 'resample') {
                stretchNode = new AudioWorkletNode(audioContext, 'resample-stretch-processor', {
                    processorOptions: {
                        stretchFactor: sliderToStretch(parseFloat(stretchSlider.value))
                    }
                });
            } else if (currentAlgorithm === 'spectral') {
                stretchNode = new AudioWorkletNode(audioContext, 'spectral-stretch-processor', {
                    processorOptions: {
                        windowSize: parseInt(windowSelect.value),
                        stretchFactor: sliderToStretch(parseFloat(stretchSlider.value)),
                        overlap: parseFloat(overlapSlider.value) / 100
                    }
                });
            } else {
                stretchNode = new AudioWorkletNode(audioContext, 'granular-stretch-processor', {
                    processorOptions: {
                        stretchFactor: sliderToStretch(parseFloat(stretchSlider.value)),
                        grainSize: parseInt(windowSelect.value),
                        overlap: parseFloat(overlapSlider.value) / 100,
                        scatter: 0.1
                    }
                });
            }

            stretchNode.connect(audioContext.destination);
            setupWorkletListeners();

            // Re-send audio if we had some loaded
            if (sourceBuffer) {
                stretchNode.port.postMessage({
                    type: 'load-audio',
                    data: { samples: Array.from(sourceBuffer) }
                });
            }
        }

        function setupWorkletListeners() {
            // Listen for messages from worklet
            stretchNode.port.onmessage = (event) => {
                const { type } = event.data;
                if (type === 'loaded') {
                    setStatus('Audio loaded. Ready to play.', 'active');
                    playBtn.disabled = false;
                    stopBtn.disabled = false;
                    playBtn.classList.add('pulse');

                    // Check for pending resume after algorithm switch
                    if (pendingResume) {
                        stretchNode.port.postMessage({ type: 'seek', data: { position: pendingResume.position } });
                        playStartPosition = pendingResume.position;
                        if (pendingResume.shouldPlay) {
                            stretchNode.port.postMessage({ type: 'play' });
                            isPlaying = true;
                            playBtn.textContent = '‚è∏ Pause';
                            playBtn.classList.remove('pulse');
                            startPlayheadAnimation();
                            setStatus('Playing...', 'active');
                        }
                        pendingResume = null;
                    }
                } else if (type === 'ended') {
                    // Reset to beginning
                    stretchNode.port.postMessage({ type: 'seek', data: { position: 0 } });
                    playhead.style.left = '0%';
                    playStartPosition = 0;

                    if (isLooping) {
                        // Restart playback
                        stretchNode.port.postMessage({ type: 'play' });
                        playStartTime = audioContext.currentTime;
                        setStatus('Looping...', 'active');
                    } else {
                        setStatus('Playback ended.', 'active');
                        isPlaying = false;
                        playBtn.textContent = '‚ñ∂ Play';
                        stopPlayheadAnimation();
                    }
                }
            };

            setStatus('Audio engine initialized.', 'active');
        }

        // ===== FILE LOADING =====

        async function loadAudioFile(file) {
            try {
                setStatus(`Loading ${file.name}...`);
                await initAudio();

                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // Get mono samples (mix down if stereo)
                let samples;
                if (audioBuffer.numberOfChannels === 1) {
                    samples = audioBuffer.getChannelData(0);
                } else {
                    // Mix to mono
                    const left = audioBuffer.getChannelData(0);
                    const right = audioBuffer.getChannelData(1);
                    samples = new Float32Array(left.length);
                    for (let i = 0; i < left.length; i++) {
                        samples[i] = (left[i] + right[i]) / 2;
                    }
                }

                sourceBuffer = samples;

                // Reset playhead
                playStartPosition = 0;
                playhead.style.left = '0%';

                console.log(`üì§ Sending ${samples.length} samples to worklet`);
                console.log(`üì§ First 10 samples:`, Array.from(samples.slice(0, 10)));
                console.log(`üì§ Max sample value:`, Math.max(...Array.from(samples.slice(0, 10000)).map(Math.abs)));

                // Send to worklet
                stretchNode.port.postMessage({
                    type: 'load-audio',
                    data: { samples: Array.from(samples) } // Convert to regular array for transfer
                });

                // Draw waveform
                drawWaveform(samples);

                setStatus(`Loaded: ${file.name} (${(samples.length / audioBuffer.sampleRate).toFixed(1)}s)`, 'active');

            } catch (err) {
                setStatus(`Error loading file: ${err.message}`, 'error');
                console.error(err);
            }
        }

        async function loadTestTrack(filename) {
            try {
                setStatus(`Fetching ${filename}...`);
                const response = await fetch(`stretch_test_audio/${filename}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const blob = await response.blob();
                const file = new File([blob], filename, { type: 'audio/wav' });
                await loadAudioFile(file);

            } catch (err) {
                setStatus(`Error loading track: ${err.message}`, 'error');
                console.error(err);
            }
        }

        // ===== PLAYBACK CONTROLS =====

        function togglePlay() {
            console.log(`üéÆ togglePlay called, stretchNode=${!!stretchNode}, isPlaying=${isPlaying}`);
            if (!stretchNode) return;

            // Stop the pulsing animation once user interacts
            playBtn.classList.remove('pulse');

            if (audioContext.state === 'suspended') {
                console.log('üéÆ Resuming suspended AudioContext');
                audioContext.resume();
            }
            console.log(`üéÆ AudioContext state: ${audioContext.state}`);

            if (isPlaying) {
                console.log('üéÆ Sending PAUSE');
                stretchNode.port.postMessage({ type: 'pause' });
                playBtn.textContent = '‚ñ∂ Play';
                stopPlayheadAnimation();
                // Save current position for resume
                const stretchFactor = sliderToStretch(parseFloat(stretchSlider.value));
                const elapsed = audioContext.currentTime - playStartTime;
                playStartPosition += elapsed / stretchFactor;
                setStatus('Paused.', 'active');
            } else {
                console.log('üéÆ Sending PLAY');
                stretchNode.port.postMessage({ type: 'play' });
                playBtn.textContent = '‚è∏ Pause';
                startPlayheadAnimation();
                setStatus('Playing...', 'active');
            }

            isPlaying = !isPlaying;
        }

        function stop() {
            if (!stretchNode) return;

            stretchNode.port.postMessage({ type: 'pause' });
            stretchNode.port.postMessage({ type: 'seek', data: { position: 0 } });
            playBtn.textContent = '‚ñ∂ Play';
            isPlaying = false;
            stopPlayheadAnimation();
            playhead.style.left = '0%';
            playStartPosition = 0;
            setStatus('Stopped.', 'active');
        }

        // ===== PLAYHEAD ANIMATION =====

        function startPlayheadAnimation() {
            playStartTime = audioContext.currentTime;
            animationFrameId = requestAnimationFrame(updatePlayhead);
        }

        function stopPlayheadAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function updatePlayhead() {
            if (!isPlaying || !sourceBuffer || !audioContext) return;

            const stretchFactor = sliderToStretch(parseFloat(stretchSlider.value));
            const elapsed = audioContext.currentTime - playStartTime;

            // In stretched time, we advance through source at 1/stretchFactor rate
            const sourceElapsed = elapsed / stretchFactor;
            const currentSourcePosition = playStartPosition + sourceElapsed;

            const sourceDuration = sourceBuffer.length / audioContext.sampleRate;
            const ratio = Math.min(currentSourcePosition / sourceDuration, 1);

            playhead.style.left = `${ratio * 100}%`;

            if (ratio < 1) {
                animationFrameId = requestAnimationFrame(updatePlayhead);
            }
        }

        // ===== VISUALIZATION =====

        function drawWaveform(samples) {
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // Set canvas size
            canvas.width = canvas.offsetWidth * dpr;
            canvas.height = canvas.offsetHeight * dpr;
            ctx.scale(dpr, dpr);

            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;

            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Draw waveform
            ctx.strokeStyle = '#00d4ff';
            ctx.lineWidth = 1;
            ctx.beginPath();

            const samplesPerPixel = Math.floor(samples.length / width);
            for (let x = 0; x < width; x++) {
                const start = x * samplesPerPixel;
                const end = start + samplesPerPixel;

                let min = 1;
                let max = -1;
                for (let i = start; i < end && i < samples.length; i++) {
                    if (samples[i] < min) min = samples[i];
                    if (samples[i] > max) max = samples[i];
                }

                const yMin = (1 - max) * height / 2;
                const yMax = (1 - min) * height / 2;

                if (x === 0) {
                    ctx.moveTo(x, yMin);
                }
                ctx.lineTo(x, yMin);
                ctx.lineTo(x, yMax);
            }

            ctx.stroke();

            // Center line
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }

        // ===== UTILITY =====

        function setStatus(message, type = '') {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // ===== EVENT LISTENERS =====

        // File drop zone
        fileDrop.addEventListener('click', () => fileInput.click());
        fileDrop.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileDrop.classList.add('dragover');
        });
        fileDrop.addEventListener('dragleave', () => fileDrop.classList.remove('dragover'));
        fileDrop.addEventListener('drop', (e) => {
            e.preventDefault();
            fileDrop.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                loadAudioFile(e.dataTransfer.files[0]);
            }
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                loadAudioFile(e.target.files[0]);
            }
        });

        // Playback controls
        playBtn.addEventListener('click', togglePlay);
        stopBtn.addEventListener('click', stop);
        loopBtn.addEventListener('click', () => {
            isLooping = !isLooping;
            loopBtn.classList.toggle('active', isLooping);
        });

        // Stretch slider
        // Track last stretch value for playhead calculation
        let lastStretchFactor = sliderToStretch(parseFloat(stretchSlider.value));

        stretchSlider.addEventListener('input', (e) => {
            const sliderValue = parseFloat(e.target.value);
            const stretch = sliderToStretch(sliderValue);
            stretchValue.textContent = stretch.toFixed(1);

            // Lock in current position before changing stretch factor
            if (isPlaying && audioContext) {
                const elapsed = audioContext.currentTime - playStartTime;
                playStartPosition += elapsed / lastStretchFactor;
                playStartTime = audioContext.currentTime;
            }
            lastStretchFactor = stretch;

            if (stretchNode) {
                stretchNode.port.postMessage({ type: 'set-stretch', data: { factor: stretch } });
            }
        });

        // Window size / Grain size
        windowSelect.addEventListener('change', (e) => {
            const value = parseInt(e.target.value);
            windowValue.textContent = value;
            if (stretchNode) {
                if (currentAlgorithm === 'spectral') {
                    stretchNode.port.postMessage({ type: 'set-window-size', data: { size: value } });
                } else {
                    stretchNode.port.postMessage({ type: 'set-grain-size', data: { size: value } });
                }
            }
        });

        // Overlap
        overlapSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            overlapValue.textContent = value.toFixed(1);
            if (stretchNode) {
                stretchNode.port.postMessage({ type: 'set-overlap', data: { overlap: value / 100 } });
            }
        });

        // Algorithm switch
        algorithmSelect.addEventListener('change', (e) => {
            // Update label text based on algorithm
            if (e.target.value === 'resample') {
                windowLabel.textContent = 'Window Size';
                windowSelect.parentElement.style.opacity = '0.5';
                overlapSlider.parentElement.style.opacity = '0.5';
            } else {
                windowLabel.textContent = e.target.value === 'spectral' ? 'Window Size' : 'Grain Size';
                windowSelect.parentElement.style.opacity = '1';
                overlapSlider.parentElement.style.opacity = '1';
            }

            if (audioContext) {
                const wasPlaying = isPlaying;

                // Calculate current position before switching
                let currentPosition = playStartPosition;
                if (wasPlaying) {
                    const stretchFactor = sliderToStretch(parseFloat(stretchSlider.value));
                    const elapsed = audioContext.currentTime - playStartTime;
                    currentPosition = playStartPosition + elapsed / stretchFactor;
                }

                // Set up pending resume
                if (sourceBuffer) {
                    pendingResume = { position: currentPosition, shouldPlay: wasPlaying };
                }

                if (isPlaying) {
                    stretchNode.port.postMessage({ type: 'pause' });
                    stopPlayheadAnimation();
                    isPlaying = false;
                }

                createStretchNode();
                const algoNames = { resample: 'Resample', spectral: 'FFT (Spectral)', granular: 'Granular' };
                setStatus(`Switched to ${algoNames[e.target.value]} algorithm`, 'active');
            }
        });

        // ===== LOAD TEST TRACKS LIST =====

        const testTracks = [
            { file: 'FF_AS_bird_chirp_run_it_back_1.wav', name: 'Bird Chirp' },
            { file: 'Julia_Run_8.wav', name: 'Julia Run' },
            { file: '5_goesr_V_befilteredV_norm_20260119_20260119_paulstretch1_pre-arrival-boost_30kHz_Master.wav', name: 'GOES CME Shock' }
        ];

        /* OLD LOCAL TEST TRACKS (commented out for later)
        const testTracks = [
            '1. Lullaby for the Heart.wav',
            '4230385_Ilium_(Original Mix).wav',
            'Fearofdark - The Coffee Zone - 01 Lovesickness.wav',
            'GOLDEN HOUR Sun & Stars Remix MASTER.wav',
            'Robert Alexander - Mist (Mastered).wav'
        ];
        */

        testTracks.forEach(track => {
            const item = document.createElement('div');
            item.className = 'track-item';
            item.innerHTML = `<span class="track-name">${track.name}</span>`;
            item.addEventListener('click', () => {
                document.querySelectorAll('.track-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                loadTestTrack(track.file);
            });
            trackList.appendChild(item);
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (sourceBuffer) {
                drawWaveform(sourceBuffer);
            }
        });

        // Click waveform to seek (and start playing if not already)
        waveformCanvas.addEventListener('click', (e) => {
            if (!sourceBuffer || !stretchNode) return;

            const rect = waveformCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const ratio = x / rect.width;
            const positionInSeconds = (sourceBuffer.length / audioContext.sampleRate) * ratio;

            console.log(`üéØ Seek click: x=${x}, ratio=${ratio.toFixed(3)}, position=${positionInSeconds.toFixed(2)}s`);

            // Resume AudioContext if suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            stretchNode.port.postMessage({ type: 'seek', data: { position: positionInSeconds } });

            // Update playhead position tracking
            playStartPosition = positionInSeconds;
            playStartTime = audioContext.currentTime;

            // Update playhead
            playhead.style.left = `${ratio * 100}%`;

            // Start playing if not already
            if (!isPlaying) {
                stretchNode.port.postMessage({ type: 'play' });
                isPlaying = true;
                playBtn.textContent = '‚è∏ Pause';
                playBtn.classList.remove('pulse');
                startPlayheadAnimation();
                setStatus('Playing...', 'active');
            }
        });

        // Make waveform cursor indicate clickability
        waveformCanvas.style.cursor = 'pointer';

        // Spacebar to toggle play/pause
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !e.target.matches('input, textarea, select')) {
                e.preventDefault();
                if (sourceBuffer) {
                    togglePlay();
                }
            }
        });
    </script>
</body>
</html>
