<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waveform Region Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #2a0606 0%, #3a0f0f 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            overflow-x: hidden;
            overflow-y: scroll;
        }

        body::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 2px 2px 8px rgba(255, 100, 100, 0.6), 0 0 20px rgba(255, 50, 50, 0.4);
        }

        /* Region Card */
        .region-card {
            position: relative;
            background: linear-gradient(135deg, rgba(255, 250, 250, 0.95) 0%, rgba(240, 200, 195, 0.95) 100%);
            border-radius: 6px;
            margin-bottom: 6px;
            box-shadow: 
                0 10px 20px rgba(80, 20, 20, 0.35),
                0 6px 12px rgba(80, 20, 20, 0.25),
                0 3px 6px rgba(255, 100, 100, 0.15),
                0 1px 3px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(200, 100, 100, 0.2);
            overflow: visible;
            transition: all 0.3s;
        }

        .region-card:hover {
            box-shadow: 
                0 12px 24px rgba(80, 20, 20, 0.4),
                0 8px 16px rgba(80, 20, 20, 0.3),
                0 4px 8px rgba(255, 100, 100, 0.2);
        }

        /* Region Header Bar */
        .region-header {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.5);
            border-top: 1px solid rgba(255, 255, 255, 0.6);
            border-bottom: 1px solid rgba(200, 100, 100, 0.2);
            border-top-left-radius: 6px;
            border-top-right-radius: 6px;
            box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.8);
            transition: background 0.2s;
            font-size: 0.9em;
        }

        .region-header:hover {
            background: rgba(255, 255, 255, 0.7);
        }

        .region-header.expanded {
            background: rgba(255, 240, 240, 0.8);
            border-bottom-color: rgba(200, 100, 100, 0.4);
        }

        .region-header:not(.expanded) {
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
        }

        .play-btn {
            width: 32px;
            height: 24px;
            border-radius: 3px;
            background: linear-gradient(145deg, #d32f3f, #a01d2a);
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            border-right: 1px solid rgba(0, 0, 0, 0.2);
            color: white;
            font-size: 0.75em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 20px;
            flex-shrink: 0;
            transition: all 0.2s;
            padding: 0;
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 2px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .play-btn:hover {
            background: linear-gradient(145deg, #e6394a, #b01f2e);
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.4),
                0 2px 3px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.25),
                inset 0 -1px 0 rgba(0, 0, 0, 0.25);
            transform: translateY(-1px);
        }

        .play-btn:active {
            transform: translateY(0px);
            box-shadow: 
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 0 2px rgba(0, 0, 0, 0.2);
        }

        .play-btn.playing {
            background: linear-gradient(145deg, #34ce57, #1e7e34);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            border-left: 1px solid rgba(255, 255, 255, 0.15);
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);
            border-right: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 2px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .region-summary {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 0.9em;
            color: #333;
        }

        .region-label {
            font-weight: 600;
            color: #333;
            margin-right: 20px;
        }

        .features-count-text {
            font-weight: 600;
            color: #333;
            margin-right: 30px;
        }

        .region-time-display {
            display: flex;
            align-items: center;
            gap: 30px;
            color: #333;
            font-size: 1.1em;
            font-weight: 500;
        }

        .region-description-preview {
            color: #666;
            font-size: 0.9em;
            font-style: italic;
            margin-left: 20px;
            max-width: 600px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .time-label {
            font-weight: 500;
            color: #666;
            margin-right: 4px;
        }

        .time-value {
            font-family: 'Monaco', 'Menlo', monospace;
            color: #333;
        }

        .collapse-icon {
            font-size: 1.2em;
            color: #c82333;
            margin-right: 20px;
            transition: transform 0.3s;
            flex-shrink: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }

        .collapse-icon:hover {
            color: #bd2130;
        }

        .region-header.expanded .collapse-icon {
            transform: rotate(180deg);
        }

        .delete-region-btn {
            background: #ffb3ba;
            color: #721c24;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.2s;
            margin-left: 20px;
            flex-shrink: 0;
        }

        .delete-region-btn:hover {
            background: #ff8a8f;
            transform: scale(1.05);
        }

        /* Delete Feature Button (inline with feature rows) */
        .delete-feature-btn-inline {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #dc3545;
            border: none;
            color: white;
            font-size: 0.7em;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }

        .delete-feature-btn-inline:hover {
            background: #c82333;
            transform: translateY(-50%) scale(1.15);
        }

        .delete-feature-btn-inline:active {
            transform: translateY(-50%) scale(0.9);
        }

        .delete-feature-btn-inline.disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .delete-feature-btn-inline.disabled:hover {
            transform: translateY(-50%);
        }

        /* Add Feature Row */
        .add-feature-row {
            background: transparent;
            padding: 1px 10px 1px 36px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            position: relative;
            min-height: 28px;
            margin-top: 2px;
        }

        .add-feature-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #5cb85c;
            border: none;
            color: white;
            font-size: 0.85em;
            font-weight: 400;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }

        .add-feature-btn:hover {
            background: #4cae4c;
            transform: scale(1.15);
        }

        .add-feature-btn:active {
            transform: scale(0.9);
        }

        .add-feature-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .add-feature-btn:disabled:hover {
            transform: none;
        }

        .add-feature-label {
            margin-left: 8px;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
            cursor: pointer;
            user-select: none;
            transition: color 0.2s;
        }

        .add-feature-label:hover {
            color: #333;
        }

        .add-feature-label.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .add-feature-label.disabled:hover {
            color: #666;
        }

        /* Region Details */
        .region-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: white;
        }

        .region-details.expanded {
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
        }

        .details-content {
            padding: 9px 12px 3px 12px;
            font-size: 0.85em;
        }

        /* Region Time Fields */
        .region-time-fields {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
            padding-bottom: 9px;
            border-bottom: 1px solid #e0e0e0;
        }

        .time-field-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .time-field-group label {
            font-size: 0.8em;
            font-weight: 600;
            color: #555;
        }

        .time-field-group input {
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.85em;
            transition: border-color 0.2s;
        }

        .time-field-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Features List */
        .features-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .features-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .feature-row {
            background: #e8e8e8;
            padding: 4px 10px 4px 58px;
            border-radius: 4px;
            border-left: 3px solid #c82333;
            display: grid;
            grid-template-columns: 110px 110px 180px 1fr;
            gap: 8px;
            align-items: stretch;
            position: relative;
            min-height: 36px;
        }

        .feature-number {
            position: absolute;
            left: 28px;
            top: 50%;
            transform: translateY(-50%);
            font-weight: 700;
            color: #333;
            font-size: 1.2em;
            width: 24px;
            text-align: center;
        }

        .feature-row:nth-child(odd) {
            background: #e8e8e8;
        }

        .feature-row:nth-child(even) {
            background: #d8d8d8;
        }


        select, input[type="text"], textarea {
            padding: 4px 6px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.95em;
            font-family: inherit;
            transition: border-color 0.2s;
        }

        select:focus, input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #c82333;
        }

        textarea.freq-input {
            resize: none;
            overflow-x: auto;
            overflow-y: hidden;
            height: 28px;
            line-height: 1.2;
            white-space: nowrap;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        textarea.freq-input::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        .freq-input {
            width: 100%;
        }

        .freq-input.pulse {
            animation: pulseReceipt 0.6s ease-out;
        }

        .freq-input.pulse-long {
            animation: pulseReceipt 1.2s ease-out;
        }

        @keyframes pulseReceipt {
            0% {
                background-color: #fff;
                border-color: #c82333;
            }
            50% {
                background-color: #ffe8e8;
                border-color: #c82333;
                box-shadow: 0 0 10px rgba(200, 35, 51, 0.5);
            }
            100% {
                background-color: #fff;
                border-color: #e0e0e0;
            }
        }


        /* Select Button */
        .select-freq-btn {
            padding: 6px 12px;
            border: 1px solid #c82333;
            border-radius: 4px;
            background: white;
            color: #c82333;
            font-size: 0.85em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .select-freq-btn:hover {
            background: #c82333;
            color: white;
        }

        .select-freq-btn.active {
            background: #c82333 !important;
            color: white !important;
            border-color: #c82333 !important;
            animation: subtleGlow 1.2s ease-in-out infinite !important;
        }

        .select-freq-btn.pulse:not(.active) {
            animation: pulseButton 1.5s ease-in-out infinite;
        }

        .select-freq-btn.completed {
            background: white;
            color: #333;
            border-color: #ccc;
            font-weight: 500;
            font-style: normal;
        }

        .select-freq-btn.completed:hover {
            background: #f5f5f5;
            color: #666;
            border-color: #999;
        }
        
        .select-freq-btn.pulse {
            animation: simplePulse 0.25s ease-out !important;
        }
        
        .select-freq-btn.expand-shadow {
            animation: expandShadow 0.3s ease-out !important;
        }
        
        @keyframes expandShadow {
            0% {
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
            50% {
                box-shadow: 0 0 0 3px rgba(200, 35, 51, 0.8), 0 0 0 6px rgba(200, 35, 51, 0.4);
            }
            100% {
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
        }
        
        @keyframes simplePulse {
            0% {
                background-color: #c82333 !important;
                color: white !important;
                border-color: #c82333 !important;
                box-shadow: 0 0 15px rgba(200, 35, 51, 0.5);
            }
            25% {
                background-color: #ff9999 !important;
                color: white !important;
                border-color: #ff5555 !important;
                box-shadow: 0 0 18px rgba(255, 70, 70, 0.6);
            }
            60% {
                background-color: #ffcccc !important;
                color: #c82333 !important;
                border-color: #ff7777 !important;
                box-shadow: 0 0 15px rgba(255, 100, 100, 0.4);
            }
            100% {
                background-color: white !important;
                color: #333 !important;
                border-color: #ccc !important;
                box-shadow: 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        @keyframes subtleGlow {
            0%, 100% {
                box-shadow: 0 0 8px rgba(200, 35, 51, 0.4);
            }
            50% {
                box-shadow: 0 0 20px rgba(200, 35, 51, 0.8);
            }
        }

        @keyframes pulseButton {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
                background: white;
                color: #c82333;
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
            50% {
                opacity: 1;
                transform: scale(1.08);
                background: #fff5f5;
                color: #c82333;
                border-color: #e85d5d;
                box-shadow: 0 0 8px rgba(200, 35, 51, 0.3);
            }
        }

        .frequency-display {
            grid-column: span 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 6px;
            color: #999;
            font-style: italic;
            font-size: 0.85em;
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            max-width: 160px;
            min-width: 120px;
        }

        .frequency-display.selected {
            color: #333;
            font-style: normal;
            font-weight: 500;
        }

        .frequency-display.pulse {
            animation: pulseFrequencyDisplay 0.8s ease-out;
        }

        .notes-field.pulse {
            animation: pulseNotesField 0.8s ease-out;
        }

        @keyframes pulseFrequencyDisplay {
            0% {
                background-color: white;
                border-color: #c82333;
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
            50% {
                background-color: #ffcccc;
                border-color: #ff0000;
                box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
            }
            100% {
                background-color: white;
                border-color: #c82333;
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
        }

        @keyframes pulseNotesField {
            0% {
                background-color: white;
                border-color: #e0e0e0;
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
            }
            50% {
                background-color: #fff5f5;
                border-color: #ffaaaa;
                box-shadow: 0 0 20px rgba(200, 35, 51, 0.8), 0 0 10px rgba(200, 35, 51, 0.5);
                transform: scale(1.005);
            }
            100% {
                background-color: white;
                border-color: #e0e0e0;
                box-shadow: 0 0 0 rgba(200, 35, 51, 0);
                transform: scale(1);
            }
        }

        /* Spectrogram Panel */
        .spectrogram-panel {
            background: linear-gradient(135deg, rgba(10, 2, 2, 0.95) 0%, rgba(50, 15, 15, 0.95) 100%);
            border: 1px solid rgba(200, 100, 100, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 8px;
            box-shadow: 
                0 10px 20px rgba(80, 20, 20, 0.35),
                0 6px 12px rgba(80, 20, 20, 0.25);
            position: relative;
        }

        .spectrogram-container {
            position: relative;
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        #spectrogram-select {
            cursor: default;
            display: block;
            width: 100%;
            height: 450px;
        }

        #spectrogram-select.selecting {
            cursor: crosshair;
        }

        #spectrogram-axis-select {
            display: block;
        }

        .selection-box {
            position: absolute;
            border: 2px solid #ff4444;
            background: rgba(255, 68, 68, 0.2);
            pointer-events: none;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: white;
            font-size: 1.2em;
        }

        .empty-state p {
            opacity: 0.9;
            margin-top: 10px;
        }

        /* Waveform Time Bar */
        .waveform-panel {
            background: linear-gradient(135deg, rgba(40, 40, 40, 0.95) 0%, rgba(60, 60, 60, 0.95) 100%);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative; /* Needed for absolute positioning of add button */
        }

        .waveform-container {
            position: relative;
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
        }

        .waveform-canvas-wrapper {
            position: relative;
            flex: 1;
            cursor: default;
        }

        #waveform-time-bar {
            width: 100%;
            height: 100px;
            display: block;
        }

        #waveform-time-axis {
            width: 100%;
            height: 40px;
            display: block;
        }

        .region-highlight {
            position: absolute;
            top: 0;
            height: 100px;
            background: rgba(68, 136, 255, 0.2);
            border-left: 2px solid rgba(68, 136, 255, 0.6);
            border-right: 2px solid rgba(68, 136, 255, 0.6);
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .region-highlight.active {
            background: rgba(68, 136, 255, 0.5);
            border-left-color: rgba(68, 136, 255, 0.9);
            border-right-color: rgba(68, 136, 255, 0.9);
        }


        .selection-box {
            position: absolute;
            top: 0;
            height: 100px;
            background: rgba(255, 255, 0, 0.2);
            border-left: 2px solid rgba(255, 200, 0, 0.8);
            border-right: 2px solid rgba(255, 200, 0, 0.8);
            pointer-events: none;
        }

        .add-region-button {
            position: absolute;
            padding: 8px 16px;
            background: #1e7e34;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            white-space: nowrap;
            opacity: 0;
        }

        .add-region-button:hover {
            background: #1a6b2e;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒ‹ Waveform Region Tracker</h1>
        
        <!-- Waveform Time Bar -->
        <div class="waveform-panel">
            <div class="waveform-container">
                <div class="waveform-canvas-wrapper" id="waveformWrapper">
                    <canvas id="waveform-time-bar" width="1200" height="100"></canvas>
                    <canvas id="waveform-time-axis" width="1200" height="40"></canvas>
                </div>
            </div>
        </div>
        
        <!-- Spectrogram Panel for Frequency Selection -->
        <div class="spectrogram-panel">
            <div class="spectrogram-container">
                <canvas id="spectrogram-select" width="1200" height="450"></canvas>
                <canvas id="spectrogram-axis-select" width="60" height="450"></canvas>
            </div>
        </div>
        
        <div id="regionsList"></div>
        
        <div id="emptyState" class="empty-state" style="display: none;">
            <h2>No regions selected</h2>
            <p>Select regions on the waveform to track events</p>
        </div>
    </div>

    <script>
        // Region data structure
        let regions = [
            {
                id: 1,
                startTime: '2025-11-13T10:23:45.123Z',
                stopTime: '2025-11-13T10:24:12.456Z',
                featureCount: 1,
                features: [
                    {
                        type: 'Impulsive',
                        repetition: 'Unique',
                        lowFreq: '',
                        highFreq: '',
                        notes: ''
                    }
                ],
                expanded: false,
                playing: false
            }
        ];

        // ===== WAVEFORM TIME BAR =====
        // Mock time data - 24 hour period starting from first region's start time
        const dataStartTime = new Date('2025-11-13T00:00:00.000Z');
        const dataEndTime = new Date('2025-11-14T00:00:00.000Z'); // 24 hours later (next day at midnight UTC)
        const totalDuration = (dataEndTime.getTime() - dataStartTime.getTime()) / 1000; // seconds
        
        let activeRegionIndex = null; // Track which region is currently active (50% opacity)
        let isSelectingTime = false;
        let selectionStartX = null;
        let selectionEndX = null;
        let selectionBoxElement = null;
        let addRegionButton = null;

        // Initialize waveform
        function initWaveform() {
            drawWaveform();
            drawTimeAxis();
            setupWaveformSelection();
            updateRegionHighlights();
            
            // Handle window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    drawWaveform();
                    drawTimeAxis();
                    updateRegionHighlights();
                }, 100);
            });
        }

        // Draw mock waveform
        function drawWaveform() {
            const canvas = document.getElementById('waveform-time-bar');
            if (!canvas) return;
            
            // Use display width for responsive sizing
            const displayWidth = canvas.offsetWidth || 1200;
            canvas.width = displayWidth;
            canvas.height = 100;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw mock waveform (sine wave with some variation)
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            const centerY = height / 2;
            const amplitude = height * 0.4;
            
            for (let x = 0; x < width; x++) {
                const t = (x / width) * Math.PI * 20; // Multiple cycles
                const variation = Math.sin((x / width) * Math.PI * 5) * 0.3;
                const y = centerY + Math.sin(t + variation) * amplitude;
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }

        // Draw time axis with ticks
        function drawTimeAxis() {
            const canvas = document.getElementById('waveform-time-axis');
            const waveformCanvas = document.getElementById('waveform-time-bar');
            if (!canvas || !waveformCanvas) return;
            
            // Use display width for responsive sizing
            const displayWidth = waveformCanvas.offsetWidth;
            canvas.width = displayWidth;
            canvas.height = 40;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate hourly ticks
            const ticks = calculateHourlyTicks(dataStartTime, dataEndTime);
            
            ctx.strokeStyle = '#888';
            ctx.fillStyle = '#ddd';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            const totalTimeSpan = dataEndTime.getTime() - dataStartTime.getTime();
            
            ticks.forEach(tick => {
                const timeOffsetMs = tick.utcTime.getTime() - dataStartTime.getTime();
                const x = (timeOffsetMs / totalTimeSpan) * width;
                
                if (x < -10 || x > width + 10) return;
                
                // Draw tick mark pointing up
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 8);
                ctx.stroke();
                
                // Format label
                let label;
                if (tick.isDayCrossing) {
                    const month = tick.localTime.getMonth() + 1;
                    const day = tick.localTime.getDate();
                    label = `${month}/${day}`;
                    ctx.font = 'bold 12px Arial';
                } else {
                    const hours = tick.localTime.getHours();
                    const minutes = tick.localTime.getMinutes();
                    if (hours === 0 && minutes === 0) {
                        label = '24:00';
                    } else {
                        label = `${hours}:${String(minutes).padStart(2, '0')}`;
                    }
                    ctx.font = '12px Arial';
                }
                
                ctx.fillText(label, x, 10);
            });
        }

        // Calculate hourly ticks (similar to waveform-x-axis-renderer.js)
        function calculateHourlyTicks(startUTC, endUTC) {
            const ticks = [];
            
            // Convert start time to local time to find boundaries
            const startLocal = new Date(startUTC);
            
            // Get local time components
            const startYear = startLocal.getFullYear();
            const startMonth = startLocal.getMonth();
            const startDay = startLocal.getDate();
            const startHours = startLocal.getHours();
            
            // Find first hour block (quantized at midnight local time)
            // Hour blocks: 00:00, 01:00, 02:00, ..., 23:00 (local time)
            let firstTickLocal = new Date(startYear, startMonth, startDay, 0, 0, 0, 0);
            
            // Round down to nearest hour boundary
            firstTickLocal.setHours(startHours, 0, 0, 0);
            
            // If we're not starting at an hour boundary, find the first one within the region
            if (firstTickLocal < startLocal) {
                // Move forward to next hour block
                firstTickLocal.setHours(firstTickLocal.getHours() + 1);
            }
            
            // Generate ticks every hour until we exceed end time
            let currentTickLocal = new Date(firstTickLocal);
            let previousTickDate = null;
            
            // Convert end time to local for comparison
            const endLocal = new Date(endUTC);
            const endLocalTime = endLocal.getTime();
            
            // Continue until we've passed the end time
            while (currentTickLocal.getTime() <= endLocalTime) {
                // Get local date string for day crossing detection
                const currentTickDate = currentTickLocal.toDateString();
                const isDayCrossing = previousTickDate !== null && previousTickDate !== currentTickDate;
                
                // Convert local time to UTC for positioning
                // JavaScript Date constructor with (year, month, day, hour) interprets as local time
                // getTime() returns UTC milliseconds, so we can use that for positioning
                const localYear = currentTickLocal.getFullYear();
                const localMonth = currentTickLocal.getMonth();
                const localDay = currentTickLocal.getDate();
                const localHour = currentTickLocal.getHours();
                
                // Create date from local components (browser interprets as local time)
                const tickDateLocal = new Date(localYear, localMonth, localDay, localHour, 0, 0, 0);
                
                // getTime() gives UTC milliseconds - use for positioning
                const tickUTCForPosition = new Date(tickDateLocal.getTime());
                
                // Check if this UTC time falls within our data range
                if (tickUTCForPosition.getTime() >= startUTC.getTime() && tickUTCForPosition.getTime() <= endUTC.getTime()) {
                    ticks.push({
                        utcTime: tickUTCForPosition, // UTC time for positioning
                        localTime: new Date(currentTickLocal), // Local time for display
                        isDayCrossing: isDayCrossing
                    });
                }
                
                previousTickDate = currentTickDate;
                
                // Move to next hour block (in local time)
                currentTickLocal.setHours(currentTickLocal.getHours() + 1);
            }
            
            // Ensure we have a tick at or very close to the end time
            // Add one more tick if the last tick is significantly before the end
            if (ticks.length > 0) {
                const lastTick = ticks[ticks.length - 1];
                const timeUntilEnd = endUTC.getTime() - lastTick.utcTime.getTime();
                const oneHourMs = 60 * 60 * 1000;
                
                // If there's more than 30 minutes until the end, add one more tick
                if (timeUntilEnd > (30 * 60 * 1000)) {
                    const endLocalDate = new Date(endUTC);
                    const endLocalYear = endLocalDate.getFullYear();
                    const endLocalMonth = endLocalDate.getMonth();
                    const endLocalDay = endLocalDate.getDate();
                    const endLocalHour = endLocalDate.getHours();
                    
                    const endTickLocal = new Date(endLocalYear, endLocalMonth, endLocalDay, endLocalHour, 0, 0, 0);
                    const endTickUTC = new Date(endTickLocal.getTime());
                    
                    if (endTickUTC.getTime() <= endUTC.getTime()) {
                        ticks.push({
                            utcTime: endTickUTC,
                            localTime: new Date(endTickLocal),
                            isDayCrossing: false
                        });
                    }
                }
            }
            
            return ticks;
        }

        // Setup waveform selection
        function setupWaveformSelection() {
            const canvas = document.getElementById('waveform-time-bar');
            const wrapper = document.getElementById('waveformWrapper');
            const panel = document.querySelector('.waveform-panel');
            if (!canvas || !wrapper || !panel) return;
            
            canvas.addEventListener('mousedown', (e) => {
                // Clear active region highlight when starting new waveform selection
                clearActiveRegion();
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                selectionStartX = x;
                isSelectingTime = true;
                canvas.style.cursor = 'col-resize';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isSelectingTime) return;
                
                const rect = canvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                selectionEndX = currentX;
                
                // Create or update selection box
                if (!selectionBoxElement) {
                    selectionBoxElement = document.createElement('div');
                    selectionBoxElement.className = 'selection-box';
                    wrapper.appendChild(selectionBoxElement);
                }
                
                const startX = Math.min(selectionStartX, selectionEndX);
                const endX = Math.max(selectionStartX, selectionEndX);
                const width = endX - startX;
                
                selectionBoxElement.style.left = startX + 'px';
                selectionBoxElement.style.width = width + 'px';
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (!isSelectingTime) return;
                
                isSelectingTime = false;
                canvas.style.cursor = 'default';
                
                // Only show button if there's a valid selection (not just a click)
                if (selectionStartX !== null && selectionEndX !== null) {
                    const startX = Math.min(selectionStartX, selectionEndX);
                    const endX = Math.max(selectionStartX, selectionEndX);
                    const selectionWidth = Math.abs(endX - startX);
                    
                    // Only show button if selection is wide enough (more than 5px)
                    if (selectionWidth > 5) {
                        // Create or get button
                        if (!addRegionButton) {
                            addRegionButton = document.createElement('button');
                            addRegionButton.className = 'add-region-button';
                            addRegionButton.textContent = '+ Add Region';
                            addRegionButton.onclick = (e) => {
                                e.stopPropagation();
                                createRegionFromSelection();
                            };
                            panel.appendChild(addRegionButton);
                        }
                        
                        // Calculate button position relative to panel (centered on selection)
                        const wrapperRect = wrapper.getBoundingClientRect();
                        const panelRect = panel.getBoundingClientRect();
                        const buttonX = wrapperRect.left - panelRect.left + (startX + endX) / 2;
                        const buttonTop = wrapperRect.top - panelRect.top - 45; // Position 45px above waveform
                        
                        // Check if button is already visible and in a different position
                        const isCurrentlyVisible = addRegionButton.style.display === 'block' && 
                                                   parseFloat(addRegionButton.style.opacity) > 0;
                        const currentLeft = parseFloat(addRegionButton.style.left) || 0;
                        const currentTop = parseFloat(addRegionButton.style.top) || 0;
                        const positionChanged = Math.abs(currentLeft - buttonX) > 1 || Math.abs(currentTop - buttonTop) > 1;
                        
                        if (isCurrentlyVisible && positionChanged) {
                            // Fade out first, then move and fade in
                            addRegionButton.style.transition = 'opacity 0.15s ease-out';
                            addRegionButton.style.opacity = '0';
                            
                            setTimeout(() => {
                                // Move to new position while invisible
                                addRegionButton.style.left = buttonX + 'px';
                                addRegionButton.style.top = buttonTop + 'px';
                                addRegionButton.style.transform = 'translateX(-50%)';
                                
                                // Fade in at new position
                                requestAnimationFrame(() => {
                                    addRegionButton.style.transition = 'opacity 0.2s ease-in';
                                    addRegionButton.style.opacity = '1';
                                });
                            }, 150); // Wait for fade out to complete
                        } else {
                            // First time showing or same position - just fade in
                            addRegionButton.style.left = buttonX + 'px';
                            addRegionButton.style.top = buttonTop + 'px';
                            addRegionButton.style.transform = 'translateX(-50%)';
                            addRegionButton.style.opacity = '0';
                            addRegionButton.style.display = 'block';
                            
                            // Fade in quickly
                            requestAnimationFrame(() => {
                                addRegionButton.style.transition = 'opacity 0.2s ease-in';
                                addRegionButton.style.opacity = '1';
                            });
                        }
                    }
                }
            });
            
            // Hide selection when clicking outside
            document.addEventListener('click', (e) => {
                // Check if clicking on a region card
                const regionCard = e.target.closest('.region-card');
                const spectrogramCanvas = document.getElementById('spectrogram-select');
                if (!regionCard) {
                    // Not clicking on a region card - clear active region if clicking elsewhere
                    // BUT keep active region if clicking on spectrogram while in selection mode
                    const isClickingSpectrogram = spectrogramCanvas && spectrogramCanvas.contains(e.target);
                    if (!canvas.contains(e.target) && !addRegionButton?.contains(e.target) && !isClickingSpectrogram) {
                        setActiveRegion(null);
                    }
                }
                
                if (!canvas.contains(e.target) && !addRegionButton?.contains(e.target)) {
                    if (selectionBoxElement) {
                        selectionBoxElement.remove();
                        selectionBoxElement = null;
                    }
                    if (addRegionButton) {
                        addRegionButton.style.display = 'none';
                    }
                    selectionStartX = null;
                    selectionEndX = null;
                }
            });
        }

        // Create region from selection
        function createRegionFromSelection() {
            if (selectionStartX === null || selectionEndX === null) return;
            
            const canvas = document.getElementById('waveform-time-bar');
            if (!canvas) return;
            
            const width = canvas.offsetWidth || canvas.width;
            const startProgress = Math.min(selectionStartX, selectionEndX) / width;
            const endProgress = Math.max(selectionStartX, selectionEndX) / width;
            
            const startTimeMs = dataStartTime.getTime() + (startProgress * (dataEndTime.getTime() - dataStartTime.getTime()));
            const endTimeMs = dataStartTime.getTime() + (endProgress * (dataEndTime.getTime() - dataStartTime.getTime()));
            
            const startTime = new Date(startTimeMs).toISOString();
            const endTime = new Date(endTimeMs).toISOString();
            
            // Collapse all existing regions before adding new one
            regions.forEach(region => {
                region.expanded = false;
            });
            
            // Create new region
            const newRegion = {
                id: regions.length > 0 ? Math.max(...regions.map(r => r.id)) + 1 : 1,
                startTime: startTime,
                stopTime: endTime,
                featureCount: 1,
                features: [{
                    type: 'Impulsive',
                    repetition: 'Unique',
                    lowFreq: '',
                    highFreq: '',
                    notes: ''
                }],
                expanded: true,
                playing: false
            };
            
            regions.push(newRegion);
            const newRegionIndex = regions.length - 1;
            renderRegions();
            
            // Animate the new region's expansion
            requestAnimationFrame(() => {
                const regionCard = document.querySelector(`[data-region-id="${newRegion.id}"]`);
                const details = regionCard ? regionCard.querySelector('.region-details') : null;
                
                if (details) {
                    // Start from 0, then animate to measured height
                    details.style.maxHeight = '0px';
                    // Force reflow
                    requestAnimationFrame(() => {
                        const targetHeight = details.scrollHeight;
                        details.style.maxHeight = targetHeight + 'px';
                    });
                }
            });
            
            // Set as active region (50% opacity)
            setActiveRegion(newRegionIndex);
            
            // Auto-enter selection mode for the first feature
            setTimeout(() => {
                startFrequencySelection(newRegionIndex, 0);
            }, 100);
            
            // Clear selection
            if (selectionBoxElement) {
                selectionBoxElement.remove();
                selectionBoxElement = null;
            }
            if (addRegionButton) {
                addRegionButton.style.display = 'none';
            }
            selectionStartX = null;
            selectionEndX = null;
        }

        // Update region highlights on waveform
        function updateRegionHighlights() {
            const wrapper = document.getElementById('waveformWrapper');
            if (!wrapper) return;
            
            // Remove existing highlights
            const existingHighlights = wrapper.querySelectorAll('.region-highlight');
            existingHighlights.forEach(h => h.remove());
            
            const canvas = document.getElementById('waveform-time-bar');
            if (!canvas) return;
            const width = canvas.offsetWidth || canvas.width;
            
            // Create highlights for each region
            regions.forEach((region, index) => {
                const startTime = new Date(region.startTime).getTime();
                const endTime = new Date(region.stopTime).getTime();
                
                const startProgress = (startTime - dataStartTime.getTime()) / (dataEndTime.getTime() - dataStartTime.getTime());
                const endProgress = (endTime - dataStartTime.getTime()) / (dataEndTime.getTime() - dataStartTime.getTime());
                
                const startX = startProgress * width;
                const endX = endProgress * width;
                const highlightWidth = endX - startX;
                
                const highlight = document.createElement('div');
                highlight.className = 'region-highlight';
                if (index === activeRegionIndex) {
                    highlight.classList.add('active');
                }
                highlight.style.left = startX + 'px';
                highlight.style.width = highlightWidth + 'px';
                highlight.dataset.regionIndex = index;
                
                wrapper.appendChild(highlight);
            });
        }

        // Set active region (50% opacity)
        function setActiveRegion(index) {
            activeRegionIndex = index;
            updateRegionHighlights();
        }
        
        // Clear active region (set to null for 20% opacity on all)
        function clearActiveRegion() {
            activeRegionIndex = null;
            updateRegionHighlights();
        }

        // Format time for display - human readable format (no seconds)
        function formatTime(isoString) {
            const date = new Date(isoString);
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        // Calculate duration
        function calculateDuration(startTime, stopTime) {
            const start = new Date(startTime);
            const stop = new Date(stopTime);
            const durationMs = stop - start;
            const seconds = (durationMs / 1000).toFixed(2);
            return `${seconds}s`;
        }

        // Render all regions
        function renderRegions() {
            console.log('--- renderRegions() called ---');
            console.log('Total regions:', regions.length);
            regions.forEach((region, index) => {
                console.log(`  Region ${index} (ID: ${region.id}): expanded=${region.expanded}`);
            });
            
            const container = document.getElementById('regionsList');
            const emptyState = document.getElementById('emptyState');
            
            if (regions.length === 0) {
                container.innerHTML = '';
                emptyState.style.display = 'block';
                updateRegionHighlights();
                return;
            }
            
            emptyState.style.display = 'none';
            container.innerHTML = '';
            
            regions.forEach((region, index) => {
                const regionCard = createRegionCard(region, index);
                container.appendChild(regionCard);
            });
            
            updateRegionHighlights();
            console.log('--- renderRegions() complete ---\n');
        }

        // Create a region card
        function createRegionCard(region, index) {
            const card = document.createElement('div');
            card.className = 'region-card';
            card.dataset.regionId = region.id;
            
            // Header bar
            const header = document.createElement('div');
            header.className = `region-header ${region.expanded ? 'expanded' : ''}`;
            header.onclick = (e) => {
                console.log('*** HEADER CLICKED ***', 'Region Index:', index, 'Region ID:', region.id);
                // Don't do anything if clicking buttons or triangle
                if (e.target.closest('.play-btn') || 
                    e.target.closest('.delete-region-btn') ||
                    e.target.closest('.collapse-icon')) {
                    console.log('Click ignored - clicked on a button or triangle');
                    return;
                }
                console.log('Click accepted - calling setActiveRegion only');
                setActiveRegion(index);
            };
            
            // Get first feature's description if region is collapsed
            const firstDescription = !region.expanded && region.features && region.features.length > 0 && region.features[0].notes 
                ? `<span class="region-description-preview">${region.features[0].notes}</span>` 
                : '';
            
            header.innerHTML = `
                <span class="collapse-icon" onclick="toggleRegion(${index}); event.stopPropagation();">â–¼</span>
                <button class="play-btn ${region.playing ? 'playing' : ''}" 
                        onclick="togglePlay(${index}); event.stopPropagation();"
                        title="Play region">
                    ${region.playing ? 'â¸' : 'â–¶'}
                </button>
                <span class="region-label">Region ${region.id}</span>
                <div class="region-summary">
                    <div class="region-time-display">
                        ${formatTime(region.startTime)} â€“ ${formatTime(region.stopTime)}
                        ${firstDescription}
                    </div>
                </div>
                <button class="delete-region-btn" 
                        onclick="deleteRegion(${index}); event.stopPropagation();"
                        title="Delete region">
                    âœ•
                </button>
            `;
            
            // Details section
            const details = document.createElement('div');
            details.className = `region-details ${region.expanded ? 'expanded' : ''}`;
            
            const detailsContent = document.createElement('div');
            detailsContent.className = 'details-content';
            
            // Region time fields removed - times are shown in header only
            const isMaxFeatures = region.featureCount >= 10;
            detailsContent.innerHTML = `
                <div class="features-list">
                    <div id="features-${region.id}" class="features-container"></div>
                    <div class="add-feature-row">
                        <button class="add-feature-btn" 
                                onclick="addFeature(${index}); event.stopPropagation();"
                                ${isMaxFeatures ? 'disabled' : ''}
                                title="${isMaxFeatures ? 'Maximum features (10) reached' : 'Add feature'}">
                            +
                        </button>
                        <span class="add-feature-label ${isMaxFeatures ? 'disabled' : ''}"
                              onclick="${isMaxFeatures ? '' : `addFeature(${index}); event.stopPropagation();`}"
                              title="${isMaxFeatures ? 'Maximum features (10) reached' : 'Add feature'}">
                            ${isMaxFeatures ? 'Max features reached' : 'Add feature'}
                        </span>
                    </div>
                </div>
            `;
            
            details.appendChild(detailsContent);
            
            card.appendChild(header);
            card.appendChild(details);
            
            // Render features after card is added to DOM
            setTimeout(() => {
                renderFeatures(region.id, index);
                
                // If region is expanded, set maxHeight immediately without animation
                if (region.expanded && details) {
                    // Disable transition temporarily
                    details.style.transition = 'none';
                    details.style.maxHeight = details.scrollHeight + 'px';
                    
                    // Re-enable transition after next frame
                    requestAnimationFrame(() => {
                        details.style.transition = '';
                    });
                }
            }, 0);
            
            return card;
        }

        // Render features for a region
        function renderFeatures(regionId, regionIndex) {
            const container = document.getElementById(`features-${regionId}`);
            if (!container) return;
            
            const region = regions[regionIndex];
            
            // Ensure featureCount matches features array length
            while (region.features.length < region.featureCount) {
                region.features.push({
                    type: 'Impulse',
                    repetition: 'Unique',
                    lowFreq: '',
                    highFreq: '',
                    notes: ''
                });
            }
            
            // Trim if featureCount is less
            if (region.features.length > region.featureCount) {
                region.features = region.features.slice(0, region.featureCount);
            }
            
            container.innerHTML = '';
            
            region.features.forEach((feature, featureIndex) => {
                const featureRow = document.createElement('div');
                featureRow.className = 'feature-row';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-feature-btn-inline';
                deleteBtn.textContent = 'Ã—';
                deleteBtn.title = featureIndex === 0 ? 'Cannot delete first feature' : 'Delete this feature';
                
                if (featureIndex === 0) {
                    deleteBtn.classList.add('disabled');
                    deleteBtn.disabled = true;
                } else {
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteSpecificFeature(regionIndex, featureIndex);
                    };
                }
                
                featureRow.innerHTML = `
                    <span class="feature-number">${featureIndex + 1}</span>
                    <select id="repetition-${regionIndex}-${featureIndex}" name="repetition-${regionIndex}-${featureIndex}" onchange="updateFeature(${regionIndex}, ${featureIndex}, 'repetition', this.value)">
                        <option value="Unique" ${feature.repetition === 'Unique' || !feature.repetition ? 'selected' : ''}>Unique</option>
                        <option value="Repeated" ${feature.repetition === 'Repeated' ? 'selected' : ''}>Repeated</option>
                    </select>
                    
                    <select id="type-${regionIndex}-${featureIndex}" name="type-${regionIndex}-${featureIndex}" onchange="updateFeature(${regionIndex}, ${featureIndex}, 'type', this.value)">
                        <option value="Impulsive" ${feature.type === 'Impulsive' || !feature.type ? 'selected' : ''}>Impulsive</option>
                        <option value="Continuous" ${feature.type === 'Continuous' ? 'selected' : ''}>Continuous</option>
                    </select>
                    
                    <button class="select-freq-btn ${!feature.lowFreq || !feature.highFreq ? 'pulse' : 'completed'}" 
                            onclick="startFrequencySelection(${regionIndex}, ${featureIndex})"
                            id="select-btn-${regionIndex}-${featureIndex}"
                            title="${feature.lowFreq && feature.highFreq ? 'click to select' : ''}">
                        ${feature.lowFreq && feature.highFreq ? 
                            `${Math.round(parseFloat(feature.lowFreq))} - ${Math.round(parseFloat(feature.highFreq))} Hz` :
                            'select frequency range'
                        }
                    </button>
                    
                    <textarea class="freq-input notes-field" 
                              placeholder="Add description..." 
                              onchange="updateFeature(${regionIndex}, ${featureIndex}, 'notes', this.value)"
                              onkeydown="if(event.key === 'Enter') { event.preventDefault(); this.blur(); }"
                              id="notes-${regionIndex}-${featureIndex}">${feature.notes || ''}</textarea>
                `;
                
                featureRow.insertBefore(deleteBtn, featureRow.firstChild);
                container.appendChild(featureRow);
            });
        }

        // Toggle region expansion
        function toggleRegion(index) {
            const region = regions[index];
            const wasExpanded = region.expanded;
            
            console.log('=== TOGGLE REGION CLICKED ===');
            console.log('Region ID:', region.id);
            console.log('Region Index:', index);
            console.log('Current State (wasExpanded):', wasExpanded);
            console.log('Will become:', !wasExpanded);
            
            // Find the elements for THIS region only
            const regionCard = document.querySelector(`[data-region-id="${region.id}"]`);
            const header = regionCard ? regionCard.querySelector('.region-header') : null;
            const details = regionCard ? regionCard.querySelector('.region-details') : null;
            
            console.log('Found region card:', !!regionCard);
            console.log('Found header element:', !!header);
            console.log('Found details element:', !!details);
            
            if (!details || !header) {
                console.log('ERROR: Could not find required elements');
                return;
            }
            
            // Toggle the state
            region.expanded = !wasExpanded;
            console.log('State updated to:', region.expanded);
            
            if (wasExpanded) {
                console.log('>>> ACTION: COLLAPSING <<<');
                // Remove expanded class from header
                header.classList.remove('expanded');
                
                // Collapse animation
                const currentHeight = details.scrollHeight;
                console.log('Current height:', currentHeight);
                details.style.maxHeight = currentHeight + 'px';
                details.style.transition = 'max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                void details.offsetHeight;
                
                requestAnimationFrame(() => {
                    console.log('Starting collapse animation to 0px');
                    details.style.maxHeight = '0px';
                    
                    // Remove expanded class from details after animation
                    setTimeout(() => {
                        details.classList.remove('expanded');
                        console.log('Collapse complete');
                        
                        // Update header to show description preview
                        const timeDisplay = header.querySelector('.region-time-display');
                        if (timeDisplay) {
                            const firstDescription = region.features && region.features.length > 0 && region.features[0].notes && region.features[0].notes.trim()
                                ? `<span class="region-description-preview">${region.features[0].notes}</span>` 
                                : '';
                            const timeText = `${formatTime(region.startTime)} â€“ ${formatTime(region.stopTime)}`;
                            timeDisplay.innerHTML = timeText + firstDescription;
                        }
                    }, 400);
                });
            } else {
                console.log('>>> ACTION: EXPANDING <<<');
                
                // Remove description preview IMMEDIATELY when expanding (before any animations)
                const timeDisplay = header.querySelector('.region-time-display');
                if (timeDisplay) {
                    const timeText = `${formatTime(region.startTime)} â€“ ${formatTime(region.stopTime)}`;
                    timeDisplay.innerHTML = timeText;
                }
                
                // Add expanded class to header and details
                header.classList.add('expanded');
                details.classList.add('expanded');
                
                // Expand animation
                details.style.maxHeight = '0px';
                details.style.transition = 'none';
                void details.offsetHeight;
                
                requestAnimationFrame(() => {
                    const targetHeight = details.scrollHeight;
                    console.log('Target height:', targetHeight);
                    details.style.transition = 'max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                    details.style.maxHeight = targetHeight + 'px';
                    console.log('Starting expand animation to', targetHeight + 'px');
                });
            }
            
            console.log('=== END TOGGLE ===\n');
        }

        // Toggle play - simplified version (no animation)
        function togglePlay(index) {
            setActiveRegion(index);
            const region = regions[index];
            
            // Find the play button for this region
            const regionCard = document.querySelector(`[data-region-id="${region.id}"]`);
            const playBtn = regionCard ? regionCard.querySelector('.play-btn') : null;
            
            if (!playBtn) return;
            
            if (!region.playing) {
                // Start "playing" - just toggle state
                region.playing = true;
                playBtn.classList.add('playing');
                playBtn.textContent = 'â¸';
                playBtn.title = 'Pause region';
                
                // Auto-stop after 1 second
                setTimeout(() => {
                    region.playing = false;
                    playBtn.classList.remove('playing');
                    playBtn.textContent = 'â–¶';
                    playBtn.title = 'Play region';
                }, 1000);
            } else {
                // Stop playing
                region.playing = false;
                playBtn.classList.remove('playing');
                playBtn.textContent = 'â–¶';
                playBtn.title = 'Play region';
            }
        }

        // Update region time
        function updateRegionTime(regionIndex, field, value) {
            regions[regionIndex][field] = value;
            // Re-render to update summary
            renderRegions();
        }

        // Update the feature count display
        function updateFeatureCountDisplay(regionIndex) {
            const region = regions[regionIndex];
            const regionCard = document.querySelector(`[data-region-id="${region.id}"]`);
            const countText = regionCard ? regionCard.querySelector('.features-count-text') : null;
            
            // Update the count text in the header
            if (countText) {
                countText.textContent = region.featureCount;
            }
        }

        // Add a feature (increment count by 1)
        function addFeature(regionIndex) {
            const region = regions[regionIndex];
            const currentCount = region.featureCount;
            
            // Max is 10 features
            if (currentCount >= 10) {
                console.log('Maximum features (10) reached');
                return;
            }
            
            updateFeatureCount(regionIndex, currentCount + 1);
        }

        // Delete a specific feature by index
        function deleteSpecificFeature(regionIndex, featureIndex) {
            const region = regions[regionIndex];
            
            // Cannot delete if only 1 feature or trying to delete the first one
            if (region.featureCount <= 1 || featureIndex === 0) {
                console.log('Cannot delete - minimum 1 feature required or attempting to delete first feature');
                return;
            }
            
            // Remove the feature from the array
            region.features.splice(featureIndex, 1);
            region.featureCount = region.features.length;
            
            // Re-render
            renderFeatures(region.id, regionIndex);
            updateFeatureCountDisplay(regionIndex);
        }

        // Update feature count
        function updateFeatureCount(regionIndex, newCount) {
            setActiveRegion(regionIndex);
            if (newCount < 1) newCount = 1;
            if (newCount > 10) newCount = 10;
            
            const region = regions[regionIndex];
            const oldCount = region.featureCount;
            
            // Update the count
            region.featureCount = newCount;
            
            // Get the current details element and its height
            const regionCard = document.querySelector(`[data-region-id="${region.id}"]`);
            const details = regionCard ? regionCard.querySelector('.region-details') : null;
            
            // Only animate when ADDING features, not removing
            if (details && region.expanded && newCount > oldCount) {
                // Capture current height
                details.style.maxHeight = 'none';
                details.style.transition = 'none';
                const currentHeight = details.scrollHeight;
                
                // Lock at current height
                details.style.maxHeight = currentHeight + 'px';
                void details.offsetHeight;
                
                // Update the DOM
                renderFeatures(region.id, regionIndex);
                updateFeatureCountDisplay(regionIndex);
                
                // Animate to new height
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        details.style.maxHeight = 'none';
                        const targetHeight = details.scrollHeight;
                        
                        details.style.maxHeight = currentHeight + 'px';
                        void details.offsetHeight;
                        
                        details.style.transition = 'max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
                        details.style.maxHeight = targetHeight + 'px';
                    });
                });
                
                // Auto-enter selection mode for the newly added feature
                setTimeout(() => {
                    startFrequencySelection(regionIndex, newCount - 1);
                }, 100);
            } else {
                // Just update instantly (for removal or when collapsed)
                renderFeatures(region.id, regionIndex);
                updateFeatureCountDisplay(regionIndex);
            }
        }

        // Update feature property
        function updateFeature(regionIndex, featureIndex, property, value) {
            setActiveRegion(regionIndex);
            if (!regions[regionIndex].features[featureIndex]) {
                regions[regionIndex].features[featureIndex] = {};
            }
            regions[regionIndex].features[featureIndex][property] = value;
            
            // If notes were updated and region is collapsed, update header preview
            if (property === 'notes' && featureIndex === 0 && !regions[regionIndex].expanded) {
                const region = regions[regionIndex];
                const regionCard = document.querySelector(`[data-region-id="${region.id}"]`);
                if (regionCard) {
                    const header = regionCard.querySelector('.region-header');
                    const timeDisplay = header ? header.querySelector('.region-time-display') : null;
                    if (timeDisplay) {
                        const firstDescription = value && value.trim()
                            ? `<span class="region-description-preview">${value}</span>` 
                            : '';
                        const timeText = `${formatTime(region.startTime)} â€“ ${formatTime(region.stopTime)}`;
                        timeDisplay.innerHTML = timeText + firstDescription;
                    }
                }
            }
        }

        // Delete region
        function deleteRegion(index) {
            if (confirm('Delete this region?')) {
                regions.splice(index, 1);
                // Clear active region if deleted
                if (activeRegionIndex === index) {
                    activeRegionIndex = null;
                } else if (activeRegionIndex > index) {
                    activeRegionIndex--; // Adjust index if region before active was deleted
                }
                renderRegions();
            }
        }

        // ===== FREQUENCY SELECTION FROM SPECTROGRAM =====
        let currentSelection = null;
        let isSelecting = false;
        let selectionBox = null;
        const maxFrequency = 50; // Hz - Nyquist frequency for 100 Hz sample rate
        const frequencyScale = 'sqrt'; // Match index.html default

        // Initialize spectrogram
        function initSpectrogram() {
            const canvas = document.getElementById('spectrogram-select');
            const axisCanvas = document.getElementById('spectrogram-axis-select');
            
            if (!canvas || !axisCanvas) return;
            
            // Use display width for responsive sizing
            const displayWidth = canvas.offsetWidth || 1200;
            canvas.width = displayWidth;
            canvas.height = 450;
            axisCanvas.width = 60;
            axisCanvas.height = 450;
            
            // Draw mock spectrogram
            drawMockSpectrogram();
            drawFrequencyAxis();
            
            // Handle window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const newWidth = canvas.offsetWidth || 1200;
                    canvas.width = newWidth;
                    drawMockSpectrogram();
                    drawFrequencyAxis();
                }, 100);
            });
        }

        // Draw mock spectrogram data
        function drawMockSpectrogram() {
            const canvas = document.getElementById('spectrogram-select');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw mock spectrogram data (simulated frequency content)
            // Use frequency bins that map to 0-50 Hz range
            const numBins = 256;
            for (let x = 0; x < width; x++) {
                for (let i = 0; i < numBins; i++) {
                    // Map bin index to frequency (0 to maxFrequency)
                    const freq = (i / numBins) * maxFrequency;
                    
                    // Simulate frequency data with some structure
                    const value = Math.random() * 255;
                    // Add some frequency-dependent variation
                    const freqFactor = Math.sin(freq * 0.5) * 0.3 + 0.7;
                    const adjustedValue = value * freqFactor;
                    const percent = adjustedValue / 255;
                    
                    const hue = percent * 60;
                    const saturation = 100;
                    const lightness = 10 + (percent * 60);
                    
                    // Calculate Y position based on frequency scale
                    const y = getYPositionForFrequency(freq, maxFrequency, height, frequencyScale);
                    const nextFreq = ((i + 1) / numBins) * maxFrequency;
                    const nextY = getYPositionForFrequency(nextFreq, maxFrequency, height, frequencyScale);
                    const barHeight = Math.max(1, Math.abs(y - nextY));
                    
                    ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(x, nextY, 1, barHeight);
                }
            }
        }

        // Draw frequency axis
        function drawFrequencyAxis() {
            const canvas = document.getElementById('spectrogram-axis-select');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Draw axis background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw frequency ticks
            ctx.strokeStyle = '#888';
            ctx.fillStyle = '#ddd';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const ticks = [0.1, 0.5, 1, 2, 5, 10, 20, 50];
            ticks.forEach(freq => {
                if (freq > maxFrequency) return;
                
                const y = getYPositionForFrequency(freq, maxFrequency, height, frequencyScale);
                
                // Draw tick mark (pointing left toward spectrogram)
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(10, y);
                ctx.stroke();
                
                // Draw label on the right side (with space from tick)
                ctx.fillText(freq.toFixed(1), width - 15, y);
            });
        }

        // Convert Y position to frequency
        function getYPositionForFrequency(freq, maxFreq, canvasHeight, scaleType) {
            const normalized = freq / maxFreq;
            
            if (scaleType === 'logarithmic') {
                const minFreq = 0.1;
                const freqSafe = Math.max(freq, minFreq);
                const logMin = Math.log10(minFreq);
                const logMax = Math.log10(maxFreq);
                const logFreq = Math.log10(freqSafe);
                const normalizedLog = (logFreq - logMin) / (logMax - logMin);
                return canvasHeight - (normalizedLog * canvasHeight);
            } else if (scaleType === 'sqrt') {
                const sqrtNormalized = Math.sqrt(normalized);
                return canvasHeight - (sqrtNormalized * canvasHeight);
            } else {
                return canvasHeight - (normalized * canvasHeight);
            }
        }

        // Convert Y position back to frequency
        function getFrequencyFromY(y, maxFreq, canvasHeight, scaleType) {
            const normalizedY = (canvasHeight - y) / canvasHeight;
            
            if (scaleType === 'logarithmic') {
                const minFreq = 0.1;
                const logMin = Math.log10(minFreq);
                const logMax = Math.log10(maxFreq);
                const logFreq = logMin + (normalizedY * (logMax - logMin));
                return Math.pow(10, logFreq);
            } else if (scaleType === 'sqrt') {
                const normalized = normalizedY * normalizedY;
                return normalized * maxFreq;
            } else {
                return normalizedY * maxFreq;
            }
        }

        // Start frequency selection
        function startFrequencySelection(regionIndex, featureIndex) {
            const button = document.getElementById(`select-btn-${regionIndex}-${featureIndex}`);
            if (!button) return;
            
            // Activate button and stop pulsing, remove completed state
            button.classList.add('active');
            button.classList.remove('pulse', 'completed');
            isSelecting = true;
            currentSelection = { regionIndex, featureIndex, button };
            
            // Enable selection on spectrogram
            const canvas = document.getElementById('spectrogram-select');
            if (canvas) {
                canvas.classList.add('selecting');
            }
        }

        // Handle spectrogram mouse events
        function setupSpectrogramSelection() {
            const canvas = document.getElementById('spectrogram-select');
            const container = document.querySelector('.spectrogram-container');
            
            if (!canvas || !container) return;
            
            let startX = null;
            let startY = null;
            let selectionBoxElement = null;
            
            // Cleanup function to reset selection state
            function cleanupSelection(wasCompleted = false) {
                if (selectionBoxElement && selectionBoxElement.parentNode) {
                    selectionBoxElement.parentNode.removeChild(selectionBoxElement);
                }
                selectionBoxElement = null;
                startX = null;
                startY = null;
                
                // Deactivate button if one was active
                if (currentSelection && currentSelection.button) {
                    currentSelection.button.classList.remove('active');
                    // Mark as completed if a selection was made
                    if (wasCompleted) {
                        currentSelection.button.classList.add('completed');
                    }
                }
                
                isSelecting = false;
                currentSelection = null;
                canvas.classList.remove('selecting');
                canvas.style.cursor = ''; // Clear any inline cursor style
            }
            
            canvas.addEventListener('mousedown', (e) => {
                if (!isSelecting) return;
                
                const rect = canvas.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;
                
                // Create selection box
                selectionBoxElement = document.createElement('div');
                selectionBoxElement.className = 'selection-box';
                const containerRect = container.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                selectionBoxElement.style.left = (startX + canvasRect.left - containerRect.left) + 'px';
                selectionBoxElement.style.top = (startY + canvasRect.top - containerRect.top) + 'px';
                selectionBoxElement.style.width = '0px';
                selectionBoxElement.style.height = '0px';
                container.appendChild(selectionBoxElement);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isSelecting || startX === null || startY === null || !selectionBoxElement) return;
                
                const rect = canvas.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                const currentY = e.clientY - rect.top;
                
                const left = Math.min(startX, currentX);
                const top = Math.min(startY, currentY);
                const width = Math.abs(currentX - startX);
                const height = Math.abs(currentY - startY);
                
                selectionBoxElement.style.left = (left + rect.left - containerRect.left) + 'px';
                selectionBoxElement.style.top = (top + rect.top - containerRect.top) + 'px';
                selectionBoxElement.style.width = width + 'px';
                selectionBoxElement.style.height = height + 'px';
            });
            
            // Use document-level mouseup to catch releases outside canvas
            function handleMouseUp(e) {
                if (!isSelecting || startX === null || startY === null || !selectionBoxElement) return;
                
                const rect = canvas.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                // Clamp coordinates to canvas bounds
                const endX = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                const endY = Math.max(0, Math.min(e.clientY - rect.top, rect.height));
                const top = Math.min(startY, endY);
                const bottom = Math.max(startY, endY);
                
                // Store final box position and size before removing
                const finalLeft = Math.min(startX, endX);
                const finalTop = top;
                const finalWidth = Math.abs(endX - startX);
                const finalHeight = Math.abs(endY - startY);
                const boxLeft = finalLeft + rect.left - containerRect.left;
                const boxTop = finalTop + rect.top - containerRect.top;
                
                // Convert Y positions to frequencies (only Y matters for frequency selection)
                const canvasHeight = canvas.height;
                const lowFreq = getFrequencyFromY(bottom, maxFrequency, canvasHeight, frequencyScale);
                const highFreq = getFrequencyFromY(top, maxFrequency, canvasHeight, frequencyScale);
                
                // Update feature data
                if (currentSelection) {
                    const regionIndex = currentSelection.regionIndex;
                    const featureIndex = currentSelection.featureIndex;
                    const regionId = regions[regionIndex].id;
                    
                    updateFeature(regionIndex, featureIndex, 'lowFreq', lowFreq.toFixed(2));
                    updateFeature(regionIndex, featureIndex, 'highFreq', highFreq.toFixed(2));
                    
                    // Re-render the feature to update the display
                    renderFeatures(regionId, regionIndex);
                    
                    // Wait for render, then pulse
                    requestAnimationFrame(() => {
                        const selectBtn = document.getElementById(`select-btn-${regionIndex}-${featureIndex}`);
                        const notesField = document.getElementById(`notes-${regionIndex}-${featureIndex}`);
                        
                        if (selectBtn) {
                            // CRITICAL: Disable transition FIRST to prevent white flash
                            selectBtn.style.transition = 'none';
                            
                            // Set button to red BEFORE removing active class
                            selectBtn.style.backgroundColor = '#c82333';
                            selectBtn.style.color = 'white';
                            selectBtn.style.borderColor = '#c82333';
                            
                            // Force a reflow to ensure styles are applied
                            void selectBtn.offsetWidth;
                            
                            // NOW remove active class - button stays red due to inline styles
                            selectBtn.classList.remove('active', 'pulse', 'completed', 'expand-shadow');
                            
                            // Force another reflow
                            void selectBtn.offsetWidth;
                            
                            // Start fade immediately and show expanding shadow at the same time
                            selectBtn.classList.add('pulse', 'expand-shadow');
                            
                            // Remove shadow after it completes
                            setTimeout(() => {
                                selectBtn.classList.remove('expand-shadow');
                            }, 300);
                            
                            // Re-enable transition after animation starts (animation overrides it anyway)
                            requestAnimationFrame(() => {
                                selectBtn.style.transition = '';
                            });
                            
                            setTimeout(() => {
                                selectBtn.classList.remove('pulse');
                                selectBtn.classList.add('completed');
                                // Clear inline styles so completed state can take over
                                selectBtn.style.backgroundColor = '';
                                selectBtn.style.color = '';
                                selectBtn.style.borderColor = '';
                            }, 250); // Pulse fade duration
                        }
                        
                        if (notesField) {
                            setTimeout(() => {
                                notesField.classList.add('pulse');
                                notesField.focus();
                                setTimeout(() => notesField.classList.remove('pulse'), 800);
                            }, 150);
                        }
                    });
                }
                
                // Remove selection box immediately
                if (selectionBoxElement && selectionBoxElement.parentNode) {
                    selectionBoxElement.parentNode.removeChild(selectionBoxElement);
                }
                selectionBoxElement = null;
                startX = null;
                startY = null;
                
                // Cleanup - do it AFTER animations
                setTimeout(() => {
                    isSelecting = false;
                    if (currentSelection) {
                        currentSelection = null;
                    }
                    canvas.classList.remove('selecting');
                }, 850);
            }
            
            // Attach to document to catch mouseup anywhere
            document.addEventListener('mouseup', handleMouseUp);
            
            // Also handle escape key to cancel selection
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && isSelecting) {
                    cleanupSelection();
                }
            });
        }

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            initWaveform();
            renderRegions();
            initSpectrogram();
            setupSpectrogramSelection();
        });
    </script>
</body>
</html>

